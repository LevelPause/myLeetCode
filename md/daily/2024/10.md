<ol>
<li>
<ul>
<li>最低票价

> <p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为&nbsp;<code>days</code>&nbsp;的数组给出。每一项是一个从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>365</code>&nbsp;的整数。</p>
> 
> <p>火车票有 <strong>三种不同的销售方式</strong> ：</p>
> 
> <ul>
> 	<li>一张 <strong>为期一天</strong> 的通行证售价为&nbsp;<code>costs[0]</code> 美元；</li>
> 	<li>一张 <strong>为期七天</strong> 的通行证售价为&nbsp;<code>costs[1]</code> 美元；</li>
> 	<li>一张 <strong>为期三十天</strong> 的通行证售价为&nbsp;<code>costs[2]</code> 美元。</li>
> </ul>
> 
> <p>通行证允许数天无限制的旅行。 例如，如果我们在第 <code>2</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>2</code> 天、第 <code>3</code> 天、第 <code>4</code> 天、第 <code>5</code> 天、第 <code>6</code> 天、第 <code>7</code> 天和第 <code>8</code> 天。</p>
> 
> <p>返回 <em>你想要完成在给定的列表&nbsp;<code>days</code>&nbsp;中列出的每一天的旅行所需要的最低消费&nbsp;</em>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>days = [1,4,6,7,8,20], costs = [2,7,15]
> <strong>输出：</strong>11
> <strong>解释： </strong>
> 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
> 在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
> 在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
> 在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
> 你总共花了 $11，并完成了你计划的每一天旅行。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
> <strong>输出：</strong>17
> <strong>解释：
> </strong>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 
> 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。
> 在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 
> 你总共花了 $17，并完成了你计划的每一天旅行。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= days.length &lt;= 365</code></li>
> 	<li><code>1 &lt;= days[i] &lt;= 365</code></li>
> 	<li><code>days</code>&nbsp;按顺序严格递增</li>
> 	<li><code>costs.length == 3</code></li>
> 	<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d01;

/**
 * https://leetcode.cn/problems/minimum-cost-for-tickets/description/
 */
class LC983 {

  class Solution {

    public int mincostTickets(int[] days, int[] costs) {
      int n = days.length;
      int max = days[n - 1];
      int[] dp = new int[max + 1];
      for (int i = 1, j = 0; j < n && i <= max; i++) {
        dp[i] = dp[i - 1];
        if (i == days[j]) {
          dp[i] = dp[Math.max(0, i - 1)] + costs[0];
          dp[i] = Math.min(dp[i], dp[Math.max(0, i - 7)] + costs[1]);
          dp[i] = Math.min(dp[i], dp[Math.max(0, i - 30)] + costs[2]);
          j++;
        }
      }
      return dp[max];
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>准时到达的列车最小时速

> <p>给你一个浮点数 <code>hour</code> ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 <code>n</code> 趟列车。另给你一个长度为 <code>n</code> 的整数数组 <code>dist</code> ，其中 <code>dist[i]</code> 表示第 <code>i</code> 趟列车的行驶距离（单位是千米）。</p>
> 
> <p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>
> 
> <ul>
> 	<li>例如，第 <code>1</code> 趟列车需要 <code>1.5</code> 小时，那你必须再等待 <code>0.5</code> 小时，搭乘在第 2 小时发车的第 <code>2</code> 趟列车。</li>
> </ul>
> 
> <p>返回能满足你准时到达办公室所要求全部列车的<strong> 最小正整数 </strong>时速（单位：千米每小时），如果无法准时到达，则返回 <code>-1</code> 。</p>
> 
> <p>生成的测试用例保证答案不超过 <code>10<sup>7</sup></code> ，且 <code>hour</code> 的 <strong>小数点后最多存在两位数字</strong> 。</p>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>dist = [1,3,2], hour = 6
> <strong>输出：</strong>1
> <strong>解释：</strong>速度为 1 时：
> - 第 1 趟列车运行需要 1/1 = 1 小时。
> - 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。
> - 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。
> - 你将会恰好在第 6 小时到达。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>dist = [1,3,2], hour = 2.7
> <strong>输出：</strong>3
> <strong>解释：</strong>速度为 3 时：
> - 第 1 趟列车运行需要 1/3 = 0.33333 小时。
> - 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。
> - 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。
> - 你将会在第 2.66667 小时到达。</pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>dist = [1,3,2], hour = 1.9
> <strong>输出：</strong>-1
> <strong>解释：</strong>不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。</pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>n == dist.length</code></li>
> 	<li><code>1 <= n <= 10<sup>5</sup></code></li>
> 	<li><code>1 <= dist[i] <= 10<sup>5</sup></code></li>
> 	<li><code>1 <= hour <= 10<sup>9</sup></code></li>
> 	<li><code>hours</code> 中，小数点后最多存在两位数字</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d02;

/*
 * https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/description/
 * */
class LC1870 {

  class Solution {
    public int minSpeedOnTime(int[] dist, double hour) {
      int n = dist.length;
      if (hour <= n - 1) {
        return -1;
      }

      int l = 1, r = (int)1e7;
      while (l < r) {
        int m = (l + r) >> 1;
        double cost = 0;
        for (int i = 0; i < n - 1; i++) {
          cost += (int)Math.ceil((double) dist[i] / m);
        }
        cost += (double) dist[n - 1] / m;
        if (cost <= hour) {
          r = m;
        } else {
          l = m + 1;
        }
      }
      return r;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>规定时间内到达终点的最小花费

> <p>一个国家有 <code>n</code> 个城市，城市编号为 <code>0</code> 到 <code>n - 1</code> ，题目保证 <strong>所有城市</strong> 都由双向道路 <b>连接在一起</b> 。道路由二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [x<sub>i</sub>, y<sub>i</sub>, time<sub>i</sub>]</code> 表示城市 <code>x<sub>i</sub></code> 和 <code>y<sub>i</sub></code> 之间有一条双向道路，耗费时间为 <code>time<sub>i</sub></code> 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p>
> 
> <p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code> 是你经过城市 <code>j</code> 需要支付的费用。</p>
> 
> <p>一开始，你在城市 <code>0</code> ，你想要在 <code>maxTime</code> <strong>分钟以内</strong> （包含 <code>maxTime</code> 分钟）到达城市 <code>n - 1</code> 。旅行的 <strong>费用</strong> 为你经过的所有城市 <strong>通行费之和</strong> （<strong>包括</strong> 起点和终点城市的通行费）。</p>
> 
> <p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code> ，请你返回完成旅行的 <strong>最小费用</strong> ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 <code>-1</code> 。</p>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png" style="width: 371px; height: 171px;" /></p>
> 
> <pre>
> <b>输入：</b>maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
> <b>输出：</b>11
> <b>解释：</b>最优路径为 0 -> 1 -> 2 -> 5 ，总共需要耗费 30 分钟，需要支付 11 的通行费。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <p><strong><img alt="" src="https://assets.leetcode.com/uploads/2021/06/04/copy-of-leetgraph1-1.png" style="width: 371px; height: 171px;" /></strong></p>
> 
> <pre>
> <b>输入：</b>maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
> <b>输出：</b>48
> <b>解释：</b>最优路径为 0 -> 3 -> 4 -> 5 ，总共需要耗费 26 分钟，需要支付 48 的通行费。
> 你不能选择路径 0 -> 1 -> 2 -> 5 ，因为这条路径耗费的时间太长。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <b>输入：</b>maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
> <b>输出：</b>-1
> <b>解释：</b>无法在 25 分钟以内从城市 0 到达城市 5 。
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 <= maxTime <= 1000</code></li>
> 	<li><code>n == passingFees.length</code></li>
> 	<li><code>2 <= n <= 1000</code></li>
> 	<li><code>n - 1 <= edges.length <= 1000</code></li>
> 	<li><code>0 <= x<sub>i</sub>, y<sub>i</sub> <= n - 1</code></li>
> 	<li><code>1 <= time<sub>i</sub> <= 1000</code></li>
> 	<li><code>1 <= passingFees[j] <= 1000</code> </li>
> 	<li>图中两个节点之间可能有多条路径。</li>
> 	<li>图中不含有自环。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d03;

import java.util.Arrays;

/*
 *
 * https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/description/
 * */
class LC1928 {

  class Solution {

    public int minCost(int maxTime, int[][] edges, int[] passingFees) {
      int n = passingFees.length;
      int[][] dp = new int[maxTime + 1][n];
      for (int i = 0; i <= maxTime; i++) {
        Arrays.fill(dp[i], Integer.MAX_VALUE);
      }
      dp[0][0] = passingFees[0];
      for (int t = 1; t <= maxTime; t++) {
        for (int[] edge : edges) {
          int i = edge[0], j = edge[1], cost = edge[2];
          if (cost <= t) {
            if (dp[t - cost][i] != Integer.MAX_VALUE) {
              dp[t][j] = Math.min(dp[t][j], dp[t - cost][i] + passingFees[j]);
            }
            if (dp[t - cost][j] != Integer.MAX_VALUE) {
              dp[t][i] = Math.min(dp[t][i], dp[t - cost][j] + passingFees[i]);
            }
          }
        }
      }
      int ans = Integer.MAX_VALUE;
      for (int i = 0; i <= maxTime; i++) {
        ans = Math.min(dp[i][n - 1], ans);
      }
      return ans == Integer.MAX_VALUE ? -1 : ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>飞机座位分配概率

> <p>有 <code>n</code> 位乘客即将登机，飞机正好有 <code>n</code> 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p>
> 
> <p>剩下的乘客将会：</p>
> 
> <ul>
> 	<li>
> 	<p>如果他们自己的座位还空着，就坐到自己的座位上，</p>
> 	</li>
> 	<li>当他们自己的座位被占用时，随机选择其他座位</li>
> </ul>
> 
> <p>第 <code>n</code>&nbsp;位乘客坐在自己的座位上的概率是多少？</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 1
> <strong>输出：</strong>1.00000
> <strong>解释：</strong>第一个人只会坐在自己的位置上。</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入:</strong> n = 2
> <strong>输出:</strong> 0.50000
> <strong>解释：</strong>在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 10^5</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d04;

/*
 * https://leetcode.cn/problems/airplane-seat-assignment-probability/description/?envType=daily-question&envId=2024-10-04
 * */
class LC1227 {

  class Solution {

    public double nthPersonGetsNthSeat(int n) {
      return n == 1 ? 1.0 : 0.5;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>完成旅途的最少时间

> <p>给你一个数组&nbsp;<code>time</code>&nbsp;，其中&nbsp;<code>time[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车完成 <strong>一趟</strong><strong>旅途</strong>&nbsp;所需要花费的时间。</p>
> 
> <p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong>&nbsp;下一趟旅途。每辆公交车 <strong>独立</strong>&nbsp;运行，也就是说可以同时有多辆公交车在运行且互不影响。</p>
> 
> <p>给你一个整数&nbsp;<code>totalTrips</code>&nbsp;，表示所有公交车&nbsp;<strong>总共</strong>&nbsp;需要完成的旅途数目。请你返回完成 <strong>至少</strong>&nbsp;<code>totalTrips</code>&nbsp;趟旅途需要花费的 <strong>最少</strong>&nbsp;时间。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><b>输入：</b>time = [1,2,3], totalTrips = 5
> <b>输出：</b>3
> <strong>解释：</strong>
> - 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。
>   已完成的总旅途数为 1 + 0 + 0 = 1 。
> - 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。
>   已完成的总旅途数为 2 + 1 + 0 = 3 。
> - 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。
>   已完成的总旅途数为 3 + 1 + 1 = 5 。
> 所以总共完成至少 5 趟旅途的最少时间为 3 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><b>输入：</b>time = [2], totalTrips = 1
> <b>输出：</b>2
> <strong>解释：</strong>
> 只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。
> 所以完成 1 趟旅途的最少时间为 2 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d05;

/*
 * https://leetcode.cn/problems/minimum-time-to-complete-trips/description/
 * */
class LC2187 {

  class Solution {

    public long minimumTime(int[] time, int totalTrips) {
      int min = Integer.MAX_VALUE;
      for (int x : time) {
        min = Math.min(x, min);
      }
      long l = 1;
      long r = (long) totalTrips * min;
      while (l < r) {
        long m = (l + r) >>> 1;
        if (check(m, time, totalTrips)) {
          r = m;
        } else {
          l = m + 1;
        }
      }
      return r;
    }

    private boolean check(long t, int[] time, int totalTrips) {
      long sum = 0L;
      for (int x : time) {
        sum += t / x;
      }
      return sum >= totalTrips;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>加油站

> <p>在一条环路上有 <code>n</code>&nbsp;个加油站，其中第 <code>i</code>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code><em>&nbsp;</em>升。</p>
> 
> <p>你有一辆油箱容量无限的的汽车，从第<em> </em><code>i</code><em> </em>个加油站开往第<em> </em><code>i+1</code><em>&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。</p>
> 
> <p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例&nbsp;1:</strong></p>
> 
> <pre>
> <strong>输入:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> <strong>输出:</strong> 3
> <strong>解释:
> </strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。</pre>
> 
> <p><strong>示例 2:</strong></p>
> 
> <pre>
> <strong>输入:</strong> gas = [2,3,4], cost = [3,4,3]
> <strong>输出:</strong> -1
> <strong>解释:
> </strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。</pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示:</strong></p>
> 
> <ul>
> 	<li><code>gas.length == n</code></li>
> 	<li><code>cost.length == n</code></li>
> 	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d06;

/*
 * https://leetcode.cn/problems/gas-station/description/
 * */
class LC134 {

  class Solution {

    public int canCompleteCircuit(int[] gas, int[] cost) {
      int ans = 0;
      int minS = 0; // 最小油量
      int s = 0; // 油量
      for (int i = 0; i < gas.length; i++) {
        s += gas[i] - cost[i]; // 在 i 处加油，然后从 i 到 i+1
        if (s < minS) {
          minS = s; // 更新最小油量
          ans = i + 1; // 注意 s 减去 cost[i] 之后，汽车在 i+1 而不是 i
        }
      }
      // 循环结束后，s 即为 gas 之和减去 cost 之和
      return s < 0 ? -1 : ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>最低加油次数

> <p>汽车从起点出发驶向目的地，该目的地位于出发位置东面 <code>target</code>&nbsp;英里处。</p>
> 
> <p>沿途有加油站，用数组&nbsp;<code>stations</code> 表示。其中 <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> 表示第 <code>i</code> 个加油站位于出发位置东面&nbsp;<code>position<sub>i</sub></code> 英里处，并且有&nbsp;<code>fuel<sub>i</sub></code>&nbsp;升汽油。</p>
> 
> <p>假设汽车油箱的容量是无限的，其中最初有&nbsp;<code>startFuel</code>&nbsp;升燃料。它每行驶 1 英里就会用掉 1 升汽油。当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。</p>
> 
> <p>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 <code>-1</code> 。</p>
> 
> <p>注意：如果汽车到达加油站时剩余燃料为 <code>0</code>，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 <code>0</code>，仍然认为它已经到达目的地。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>target = 1, startFuel = 1, stations = []
> <strong>输出：</strong>0
> <strong>解释：</strong>可以在不加油的情况下到达目的地。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>target = 100, startFuel = 1, stations = [[10,100]]
> <strong>输出：</strong>-1
> <strong>解释：</strong>无法抵达目的地，甚至无法到达第一个加油站。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
> <strong>输出：</strong>2
> <strong>解释：</strong>
> 出发时有 10 升燃料。
> 开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
> 然后，从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
> 并将汽油从 10 升加到 50 升。然后开车抵达目的地。
> 沿途在两个加油站停靠，所以返回 2 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= stations.length &lt;= 500</code></li>
> 	<li><code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code></li>
> 	<li><code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d07;

import java.util.PriorityQueue;

/*
 * https://leetcode.cn/problems/minimum-number-of-refueling-stops/description/
 * */
class LC871 {

  class Solution {

    public int minRefuelStops(int target, int startFuel, int[][] stations) {
      if (startFuel >= target) {
        return 0;
      }
      int n = stations.length;
      PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
      int fuel = startFuel, ans = 0, pre = 0;
      for (int i = 0; i <= n; i++) {
        // 当前所到加油站位置, i==n时代表没有加油站了, 下一站只能直接开到终点
        int curr = i < n ? stations[i][0] : target;
        // 扣除到达当前站所用汽油
        fuel -= curr - pre;
        // 汽油小于0, 表示油不够, 则从之前走过的加油站加油, 从大到小加
        while (fuel < 0 && !pq.isEmpty()) {
          fuel += pq.poll();
          ans++;
        }
        // 加过油还是不够, 说明走不到当前站点
        if (fuel < 0) {
          return -1;
        }
        // 走到的站点是加油站时, 将油放入队列以供以后加油, 并更新最新到达的位置
        if (i < n) {
          pq.offer(stations[i][1]);
          pre = curr;
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>旅行终点站

> <p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> 表示该线路将会从 <code>cityA<sub>i</sub></code> 直接前往 <code>cityB<sub>i</sub></code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
> 
> <p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
> <strong>输出：</strong>"Sao Paulo" 
> <strong>解释：</strong>从 "London" 出发，最后抵达终点站 "Sao Paulo" 。本次旅行的路线是 "London" -&gt; "New York" -&gt; "Lima" -&gt; "Sao Paulo" 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>paths = [["B","C"],["D","B"],["C","A"]]
> <strong>输出：</strong>"A"
> <strong>解释：</strong>所有可能的线路是：
> "D" -&gt; "B" -&gt; "C" -&gt; "A".&nbsp;
> "B" -&gt; "C" -&gt; "A".&nbsp;
> "C" -&gt; "A".&nbsp;
> "A".&nbsp;
> 显然，旅行终点站是 "A" 。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>paths = [["A","Z"]]
> <strong>输出：</strong>"Z"
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= paths.length &lt;= 100</code></li>
> 	<li><code>paths[i].length == 2</code></li>
> 	<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>
> 	<li><code>cityA<sub>i&nbsp;</sub>!=&nbsp;cityB<sub>i</sub></code></li>
> 	<li>所有字符串均由大小写英文字母和空格字符组成。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d08;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/*
 * https://leetcode.cn/problems/destination-city/description/?envType=daily-question&envId=2024-10-08
 * */
class LC1436 {

  class Solution {

    public String destCity(List<List<String>> paths) {
      Set<String> set = new HashSet<>();
      for (List<String> path : paths) {
        set.add(path.get(1));
      }
      for (List<String> path : paths) {
        set.remove(path.get(0));
      }
      return set.iterator().next();
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3171

> <p>给你一个数组&nbsp;<code>nums</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。你需要找到&nbsp;<code>nums</code>&nbsp;的一个&nbsp;<span data-keyword="subarray-nonempty">子数组</span>&nbsp;，满足子数组中所有元素按位或运算 <code>OR</code> 的值与 <code>k</code>&nbsp;的 <strong>绝对差</strong>&nbsp;尽可能 <strong>小</strong>&nbsp;。换言之，你需要选择一个子数组&nbsp;<code>nums[l..r]</code>&nbsp;满足 <code>|k - (nums[l] OR nums[l + 1] ... OR nums[r])|</code>&nbsp;最小。</p>
> 
> <p>请你返回 <strong>最小</strong>&nbsp;的绝对差值。</p>
> 
> <p><strong>子数组 </strong>是数组中连续的&nbsp;<strong>非空</strong>&nbsp;元素序列。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,4,5], k = 3</span></p>
> 
> <p><span class="example-io"><b>输出：</b>0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>子数组&nbsp;<code>nums[0..1]</code> 的按位 <code>OR</code> 运算值为 3 ，得到最小差值&nbsp;<code>|3 - 3| = 0</code> 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,3,1,3], k = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>子数组&nbsp;<code>nums[1..1]</code> 的按位 <code>OR</code> 运算值为 3 ，得到最小差值&nbsp;<code>|3 - 2| = 1</code> 。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1], k = 10</span></p>
> 
> <p><span class="example-io"><b>输出：</b>9</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>只有一个子数组，按位 <code>OR</code> 运算值为 1 ，得到最小差值&nbsp;<code>|10 - 1| = 9</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d09;

/*
 * https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/description/
 * */
class LC3171 {

  class Solution {

    public int minimumDifference(int[] nums, int k) {
      int ans = Integer.MAX_VALUE;
      int n = nums.length;
      for (int i = 0; i < n; i++) {
        int x = nums[i];
        ans = Math.min(ans, Math.abs(x - k));
        for (int j = i - 1; j >= 0 && (nums[j] | x) != nums[j]; j--) {
          nums[j] |= x;
          ans = Math.min(ans, Math.abs(nums[j] - k));
          if (nums[j] > k) {
            break;
          }
          if (ans == 0) {
            return ans;
          }
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3162

> <p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>，长度分别为 <code>n</code> 和 <code>m</code>。同时给你一个<strong>正整数</strong> <code>k</code>。</p>
> 
> <p>如果 <code>nums1[i]</code> 可以除尽&nbsp;<code>nums2[j] * k</code>，则称数对 <code>(i, j)</code> 为 <strong>优质数对</strong>（<code>0 &lt;= i &lt;= n - 1</code>, <code>0 &lt;= j &lt;= m - 1</code>）。</p>
> 
> <p>返回<strong> 优质数对 </strong>的总数。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums1 = [1,3,4], nums2 = [1,3,4], k = 1</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">5</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>5个优质数对分别是 <code>(0, 0)</code>, <code>(1, 0)</code>, <code>(1, 1)</code>, <code>(2, 0)</code>, 和 <code>(2, 2)</code>。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums1 = [1,2,4,12], nums2 = [2,4], k = 3</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>2个优质数对分别是 <code>(3, 0)</code> 和 <code>(3, 1)</code>。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n, m &lt;= 50</code></li>
> 	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 50</code></li>
> 	<li><code>1 &lt;= k &lt;= 50</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d10;

import java.util.HashMap;
import java.util.Map;
/*
* https://leetcode.cn/problems/find-the-number-of-good-pairs-i/description/
* */
class LC3162 {

  class Solution {

    public int numberOfPairs(int[] nums1, int[] nums2, int k) {
      int max = 0;
      for (int x : nums1) {
        max = Math.max(x, max);
      }
      int[] dp = new int[max / k + 1];
      for (int x : nums1) {
        if (x % k == 0) {
          dp[x / k]++;
        }
      }
      int ans = 0;
      Map<Integer, Integer> cnt = new HashMap<>();
      for (int y : nums2) {
        if (cnt.containsKey(y)) {
          ans += cnt.get(y);
        } else {
          int occ = 0;
          for (int i = y; i <= max / k; i += y) {
            occ += dp[i];
          }
          ans += occ;
          cnt.put(y, occ);
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3164

> <p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>，长度分别为 <code>n</code> 和 <code>m</code>。同时给你一个<strong>正整数</strong> <code>k</code>。</p>
> 
> <p>如果 <code>nums1[i]</code> 可以被 <code>nums2[j] * k</code> 整除，则称数对 <code>(i, j)</code> 为 <strong>优质数对</strong>（<code>0 &lt;= i &lt;= n - 1</code>, <code>0 &lt;= j &lt;= m - 1</code>）。</p>
> 
> <p>返回<strong> 优质数对 </strong>的总数。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums1 = [1,3,4], nums2 = [1,3,4], k = 1</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">5</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>5个优质数对分别是 <code>(0, 0)</code>, <code>(1, 0)</code>, <code>(1, 1)</code>, <code>(2, 0)</code>, 和 <code>(2, 2)</code>。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums1 = [1,2,4,12], nums2 = [2,4], k = 3</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>2个优质数对分别是 <code>(3, 0)</code> 和 <code>(3, 1)</code>。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 10<sup>6</sup></code></li>
> 	<li><code>1 &lt;= k &lt;= 10<sup>3</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d11;

import java.util.HashMap;
import java.util.Map;

/*
 * https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/
 * */
class LC3164 {

  class Solution {

    public long numberOfPairs(int[] nums1, int[] nums2, int k) {
      int max = 0;
      for (int x : nums1) {
        max = Math.max(x, max);
      }
      int[] dp = new int[max / k + 1];
      for (int x : nums1) {
        if (x % k == 0) {
          dp[x / k]++;
        }
      }
      long ans = 0L;
      Map<Integer, Integer> cnt = new HashMap<>();
      for (int y : nums2) {
        if (cnt.containsKey(y)) {
          ans += cnt.get(y);
        } else {
          int occ = 0;
          for (int i = y; i <= max / k; i += y) {
            occ += dp[i];
          }
          ans += occ;
          cnt.put(y, occ);
        }
      }
      return ans;

    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3158

> <p>给你一个数组&nbsp;<code>nums</code>&nbsp;，数组中的数字 <strong>要么</strong> 出现一次，<strong>要么</strong>&nbsp;出现两次。</p>
> 
> <p>请你返回数组中所有出现两次数字的按位<em>&nbsp;</em><code>XOR</code>&nbsp;值，如果没有数字出现过两次，返回 0 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,1,3]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code>&nbsp;中唯一出现过两次的数字是 1 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,3]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code>&nbsp;中没有数字出现两次。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,2,1]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>3</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>数字 1 和&nbsp;2 出现过两次。<code>1 XOR 2 == 3</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
> 	<li><code>nums</code>&nbsp;中每个数字要么出现过一次，要么出现过两次。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d12;

/*
 * https://leetcode.cn/problems/find-the-xor-of-numbers-which-appear-twice/description/
 * */
class LC3158 {

  class Solution {

    public int duplicateNumbersXOR(int[] nums) {
      long vis = 0L;
      int ans = 0;
      for (int x : nums) {
        if ((vis >> x & 1) == 1) {
          ans ^= x;
        }
        vis |= 1L << x;
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>鸡蛋掉落-两枚鸡蛋

> <p>给你 <strong>2&nbsp;枚相同 </strong>的鸡蛋，和一栋从第 <code>1</code>&nbsp;层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>
> 
> <p>已知存在楼层 <code>f</code> ，满足&nbsp;<code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于 </strong><code>f</code> 的楼层落下的鸡蛋都<strong> 会碎 </strong>，从 <strong><code>f</code> 楼层或比它低 </strong>的楼层落下的鸡蛋都 <strong>不会碎 </strong>。</p>
> 
> <p>每次操作，你可以取一枚<strong> 没有碎</strong> 的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足&nbsp;<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中<strong> 重复使用 </strong>这枚鸡蛋。</p>
> 
> <p>请你计算并返回要确定 <code>f</code> <strong>确切的值 </strong>的 <strong>最小操作次数</strong> 是多少？</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 2
> <strong>输出：</strong>2
> <strong>解释：</strong>我们可以将第一枚鸡蛋从 1 楼扔下，然后将第二枚从 2 楼扔下。
> 如果第一枚鸡蛋碎了，可知 f = 0；
> 如果第二枚鸡蛋碎了，但第一枚没碎，可知 f = 1；
> 否则，当两个鸡蛋都没碎时，可知 f = 2。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 100
> <strong>输出：</strong>14
> <strong>解释：
> </strong>一种最优的策略是：
> - 将第一枚鸡蛋从 9 楼扔下。如果碎了，那么 f 在 0 和 8 之间。将第二枚从 1 楼扔下，然后每扔一次上一层楼，在 8 次内找到 f 。总操作次数 = 1 + 8 = 9 。
> - 如果第一枚鸡蛋没有碎，那么再把第一枚鸡蛋从 22 层扔下。如果碎了，那么 f 在 9 和 21 之间。将第二枚鸡蛋从 10 楼扔下，然后每扔一次上一层楼，在 12 次内找到 f 。总操作次数 = 2 + 12 = 14 。
> - 如果第一枚鸡蛋没有再次碎掉，则按照类似的方法从 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99 和 100 楼分别扔下第一枚鸡蛋。
> 不管结果如何，最多需要扔 14 次来确定 f 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 1000</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d13;

/*
 * https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/description/
 * */
class LC1884 {

  class Solution {

    public int twoEggDrop(int n) {
      return (int) Math.ceil((-1.0 + Math.sqrt(n * 8 + 1)) / 2);
    }

    private int twoEggDrop1(int n) {
      int t = 1;
      while (calc(2, t) < n + 1) {
        t++;
      }
      return t;
    }

    private int calc(int k, int t) {

      if (k == 1 || t == 1) {
        return t + 1;
      }
      return calc(k - 1, t - 1) + calc(k, t - 1);
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>鸡蛋掉落

> <p>给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。</p>
> 
> <p>已知存在楼层 <code>f</code> ，满足 <code>0 <= f <= n</code> ，任何从<strong> 高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。</p>
> 
> <p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 <= x <= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。</p>
> 
> <p>请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作次数</strong> 是多少？</p>
>  
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>k = 1, n = 2
> <strong>输出：</strong>2
> <strong>解释：</strong>
> 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 
> 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 
> 如果它没碎，那么肯定能得出 f = 2 。 
> 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>k = 2, n = 6
> <strong>输出：</strong>3
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>k = 3, n = 14
> <strong>输出：</strong>4
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 <= k <= 100</code></li>
> 	<li><code>1 <= n <= 10<sup>4</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d14;

/*
 * https://leetcode.cn/problems/super-egg-drop/description/
 * */
class LC887 {

  //谷歌经典面试题
  class Solution {

    private int[][] memo;

    public int superEggDrop(int k, int n) {
      int t = 1;
      memo = new int[k + 1][n + 1];
      while (calc(k, t) < n + 1) {
        t++;
      }
      return t;
    }

    private int calc(int k, int t) {
      if (memo[k][t] != 0) {
        return memo[k][t];
      }
      if (k == 1 || t == 1) {
        return t + 1;
      }
      return memo[k][t] = calc(k - 1, t - 1) + calc(k, t - 1);
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3200

> <p>给你两个整数 <code>red</code> 和 <code>blue</code>，分别表示红色球和蓝色球的数量。你需要使用这些球来组成一个三角形，满足第 1 行有 1 个球，第 2 行有 2 个球，第 3 行有 3 个球，依此类推。</p>
> 
> <p>每一行的球必须是 <strong>相同 </strong>颜色，且相邻行的颜色必须<strong> 不同</strong>。</p>
> 
> <p>返回可以实现的三角形的 <strong>最大 </strong>高度。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">red = 2, blue = 4</span></p>
> 
> <p><strong>输出：</strong> 3</p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/16/brb.png" style="width: 300px; height: 240px; padding: 10px;" /></p>
> 
> <p>上图显示了唯一可能的排列方式。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">red = 2, blue = 1</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/16/br.png" style="width: 150px; height: 135px; padding: 10px;" /><br />
> 上图显示了唯一可能的排列方式。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">red = 1, blue = 1</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">1</span></p>
> </div>
> 
> <p><strong class="example">示例 4：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">red = 10, blue = 1</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/06/16/br.png" style="width: 150px; height: 135px; padding: 10px;" /><br />
> 上图显示了唯一可能的排列方式。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= red, blue &lt;= 100</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d15;

/**
 * https://leetcode.cn/problems/maximum-height-of-a-triangle/description/
 */
class LC3200 {

  class Solution {

    public int maxHeightOfTriangle(int red, int blue) {
      return O1(red, blue);
    }

    private int On(int red, int blue) {
      var cnt = new int[2];
      int i = 0;
      while (true) {
        cnt[i & 1] += i;
        if ((cnt[0] > red || cnt[1] > blue) && (cnt[1] > red || cnt[0] > blue)) {
          return i - 1;
        }
        i++;
      }
    }

    private int O1(int red, int blue) {
      return Math.max(solve(red, blue), solve(blue, red));
    }

    private int solve(int m, int n) {
      var odd = (int) Math.sqrt(n);
      var even = (int) ((Math.sqrt(m * 4 + 1) - 1) / 2);
      return odd > even ? even * 2 + 1 : odd * 2;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3194

> <p>你有一个初始为空的浮点数数组 <code>averages</code>。另给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，其中 <code>n</code> 为偶数。</p>
> 
> <p>你需要重复以下步骤 <code>n / 2</code> 次：</p>
> 
> <ul>
> 	<li>从 <code>nums</code> 中移除<strong> 最小 </strong>的元素 <code>minElement</code> 和<strong> 最大 </strong>的元素 <code>maxElement</code>。</li>
> 	<li>将 <code>(minElement + maxElement) / 2</code> 加入到 <code>averages</code> 中。</li>
> </ul>
> 
> <p>返回 <code>averages</code> 中的 <strong>最小 </strong>元素。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">nums = [7,8,3,4,15,13,4,1]</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">5.5</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <table>
> 	<tbody>
> 		<tr>
> 			<th>步骤</th>
> 			<th>nums</th>
> 			<th>averages</th>
> 		</tr>
> 		<tr>
> 			<td>0</td>
> 			<td>[7,8,3,4,15,13,4,1]</td>
> 			<td>[]</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>[7,8,3,4,13,4]</td>
> 			<td>[8]</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>[7,8,4,4]</td>
> 			<td>[8,8]</td>
> 		</tr>
> 		<tr>
> 			<td>3</td>
> 			<td>[7,4]</td>
> 			<td>[8,8,6]</td>
> 		</tr>
> 		<tr>
> 			<td>4</td>
> 			<td>[]</td>
> 			<td>[8,8,6,5.5]</td>
> 		</tr>
> 	</tbody>
> </table>
> 返回 averages 中最小的元素，即 5.5。</div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">nums = [1,9,8,3,10,5]</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">5.5</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <table>
> 	<tbody>
> 		<tr>
> 			<th>步骤</th>
> 			<th>nums</th>
> 			<th>averages</th>
> 		</tr>
> 		<tr>
> 			<td>0</td>
> 			<td>[1,9,8,3,10,5]</td>
> 			<td>[]</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>[9,8,3,5]</td>
> 			<td>[5.5]</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>[8,5]</td>
> 			<td>[5.5,6]</td>
> 		</tr>
> 		<tr>
> 			<td>3</td>
> 			<td>[]</td>
> 			<td>[5.5,6,6.5]</td>
> 		</tr>
> 	</tbody>
> </table>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">nums = [1,2,3,7,8,9]</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">5.0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <table>
> 	<tbody>
> 		<tr>
> 			<th>步骤</th>
> 			<th>nums</th>
> 			<th>averages</th>
> 		</tr>
> 		<tr>
> 			<td>0</td>
> 			<td>[1,2,3,7,8,9]</td>
> 			<td>[]</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>[2,3,7,8]</td>
> 			<td>[5]</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>[3,7]</td>
> 			<td>[5,5]</td>
> 		</tr>
> 		<tr>
> 			<td>3</td>
> 			<td>[]</td>
> 			<td>[5,5,5]</td>
> 		</tr>
> 	</tbody>
> </table>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= n == nums.length &lt;= 50</code></li>
> 	<li><code>n</code> 为偶数。</li>
> 	<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d16;

import java.util.Arrays;

/**
 * https://leetcode.cn/problems/minimum-average-of-smallest-and-largest-elements/description/
 */
class LC3194 {

  class Solution {

    public double minimumAverage(int[] nums) {
      var n = nums.length;
      Arrays.sort(nums);
      var l = 0;
      var r = n - 1;
      var ans = Integer.MAX_VALUE;
      while (l < r) {
        var min = nums[l];
        var max = nums[r];
        ans = Math.min(min + max, ans);
        l++;
        r--;
      }
      return ans / 2.0;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3193

> <p>给你一个整数&nbsp;<code>n</code>&nbsp;和一个二维数组&nbsp;<code>requirements</code>&nbsp;，其中&nbsp;<code>requirements[i] = [end<sub>i</sub>, cnt<sub>i</sub>]</code> <span class="text-only" data-eleid="10" style="white-space: pre;">表示这个要求中的末尾下标和 <strong>逆序对</strong> 的数目。</span></p>
> 
> <p>整数数组 <code>nums</code>&nbsp;中一个下标对&nbsp;<code>(i, j)</code>&nbsp;如果满足以下条件，那么它们被称为一个 <strong>逆序对</strong>&nbsp;：</p>
> 
> <ul>
> 	<li><code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i] &gt; nums[j]</code></li>
> </ul>
> 
> <p>请你返回&nbsp;<code>[0, 1, 2, ..., n - 1]</code>&nbsp;的&nbsp;<span data-keyword="permutation">排列</span> <code>perm</code>&nbsp;的数目，满足对 <strong>所有</strong>&nbsp;的&nbsp;<code>requirements[i]</code>&nbsp;都有&nbsp;<code>perm[0..end<sub>i</sub>]</code>&nbsp;恰好有&nbsp;<code>cnt<sub>i</sub></code>&nbsp;个逆序对。</p>
> 
> <p>由于答案可能会很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>n = 3, requirements = [[2,2],[0,0]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>两个排列为：</p>
> 
> <ul>
> 	<li><code>[2, 0, 1]</code>
> 
> 	<ul>
> 		<li>前缀&nbsp;<code>[2, 0, 1]</code>&nbsp;的逆序对为&nbsp;<code>(0, 1)</code> 和&nbsp;<code>(0, 2)</code>&nbsp;。</li>
> 		<li>前缀&nbsp;<code>[2]</code>&nbsp;的逆序对数目为 0 个。</li>
> 	</ul>
> 	</li>
> 	<li><code>[1, 2, 0]</code>
> 	<ul>
> 		<li>前缀&nbsp;<code>[1, 2, 0]</code>&nbsp;的逆序对为&nbsp;<code>(0, 2)</code> 和&nbsp;<code>(1, 2)</code>&nbsp;。</li>
> 		<li>前缀&nbsp;<code>[1]</code>&nbsp;的逆序对数目为 0 个。</li>
> 	</ul>
> 	</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>n = 3, requirements = [[2,2],[1,1],[0,0]]</span></p>
> 
> <p><b>输出：</b>1</p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>唯一满足要求的排列是&nbsp;<code>[2, 0, 1]</code>&nbsp;：</p>
> 
> <ul>
> 	<li>前缀&nbsp;<code>[2, 0, 1]</code>&nbsp;的逆序对为&nbsp;<code>(0, 1)</code> 和&nbsp;<code>(0, 2)</code>&nbsp;。</li>
> 	<li>前缀&nbsp;<code>[2, 0]</code>&nbsp;的逆序对为&nbsp;<code>(0, 1)</code>&nbsp;。</li>
> 	<li>前缀&nbsp;<code>[2]</code>&nbsp;的逆序对数目为 0 。</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>n = 2, requirements = [[0,0],[1,0]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><b>解释：</b></p>
> 
> <p>唯一满足要求的排列为&nbsp;<code>[0, 1]</code>&nbsp;：</p>
> 
> <ul>
> 	<li>前缀&nbsp;<code>[0]</code>&nbsp;的逆序对数目为 0 。</li>
> 	<li>前缀&nbsp;<code>[0, 1]</code>&nbsp;的逆序对为&nbsp;<code>(0, 1)</code>&nbsp;。</li>
> </ul>
> </div>
> 
> <div id="gtx-trans" style="position: absolute; left: 198px; top: 756px;">
> <div class="gtx-trans-icon">&nbsp;</div>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= n &lt;= 300</code></li>
> 	<li><code>1 &lt;= requirements.length &lt;= n</code></li>
> 	<li><code>requirements[i] = [end<sub>i</sub>, cnt<sub>i</sub>]</code></li>
> 	<li><code>0 &lt;= end<sub>i</sub> &lt;= n - 1</code></li>
> 	<li><code>0 &lt;= cnt<sub>i</sub> &lt;= 400</code></li>
> 	<li>输入保证至少有一个&nbsp;<code>i</code>&nbsp;满足&nbsp;<code>end<sub>i</sub> == n - 1</code>&nbsp;。</li>
> 	<li>输入保证所有的&nbsp;<code>end<sub>i</sub></code>&nbsp;互不相同。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d17;

import java.util.Arrays;

/*
 * https://leetcode.cn/problems/count-the-number-of-inversions/description/
 * */
class LC3193 {

  class Solution {

    private static final int MOD = (int) 1e9 + 7;

    public int numberOfPermutations(int n, int[][] requirements) {
      var req = new int[n];
      Arrays.fill(req, -1);
      req[0] = 0;
      var max = 0;
      for (int[] row : requirements) {
        req[row[0]] = row[1];
        max = Math.max(row[1], max);
      }
      if (req[0] > 0) {
        return 0;
      }
      var dp = new int[n][max + 1];
      dp[0][0] = 1;
      for (int i = 1; i < n; i++) {
        var t = req[i];
        if (t >= 0) {
          for (int k = 0; k <= i; k++) {
            if (t >= k) {
              dp[i][t] = (dp[i][t] + dp[i - 1][t - k]) % MOD;
            } else {
              break;
            }
          }
        } else {
          var total = 0;
          for (int j = 0; j <= max; j++) {
            total = (total + dp[i - 1][j]) % MOD;
            if (j - (i + 1) >= 0) {
              total = (total - dp[i - 1][j - (i + 1)] + MOD) % MOD;
            }
            dp[i][j] = total;
          }
        }
      }
      return dp[n - 1][max];
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3191

> <p>给你一个二进制数组&nbsp;<code>nums</code>&nbsp;。</p>
> 
> <p>你可以对数组执行以下操作 <strong>任意</strong>&nbsp;次（也可以 0 次）：</p>
> 
> <ul>
> 	<li>选择数组中 <strong>任意连续</strong>&nbsp;3 个元素，并将它们 <strong>全部反转</strong>&nbsp;。</li>
> </ul>
> 
> <p><strong>反转</strong>&nbsp;一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。</p>
> 
> <p>请你返回将 <code>nums</code>&nbsp;中所有元素变为 1 的 <strong>最少</strong>&nbsp;操作次数。如果无法全部变成 1 ，返回 -1 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [0,1,1,1,0,0]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>3</span></p>
> 
> <p><strong>解释：</strong><br />
> 我们可以执行以下操作：</p>
> 
> <ul>
> 	<li>选择下标为 0 ，1 和 2 的元素并反转，得到&nbsp;<code>nums = [<u><strong>1</strong></u>,<u><strong>0</strong></u>,<u><strong>0</strong></u>,1,0,0]</code>&nbsp;。</li>
> 	<li>选择下标为 1 ，2 和 3 的元素并反转，得到&nbsp;<code>nums = [1,<u><strong>1</strong></u>,<u><strong>1</strong></u>,<strong><u>0</u></strong>,0,0]</code>&nbsp;。</li>
> 	<li>选择下标为 3 ，4 和 5 的元素并反转，得到&nbsp;<code>nums = [1,1,1,<strong><u>1</u></strong>,<u><strong>1</strong></u>,<u><strong>1</strong></u>]</code>&nbsp;。</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [0,1,1,1]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>-1</span></p>
> 
> <p><strong>解释：</strong><br />
> 无法将所有元素都变为 1 。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>3 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= nums[i] &lt;= 1</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d18;

/*
 * https://leetcode.cn/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description/
 * */
class LC3191 {

  public int minOperations(int[] nums) {
    int n = nums.length;
    int ans = 0;
    for (int i = 0; i < n - 2; i++) {
      if (nums[i] == 0) { // 必须操作
        nums[i + 1] ^= 1;
        nums[i + 2] ^= 1;
        ans++;
      }
    }
    return nums[n - 2] != 0 && nums[n - 1] != 0 ? ans : -1;
  }
}
```
</li>
<li>kotlin solution

```kotlin
package com.hyperboat.daily.y2024.m10.d18

class Solution {
    fun minOperations(nums: IntArray): Int {
        val n = nums.size
        var ans = 0
        for (i in 0 until n - 2) {
            if (nums[i] == 0) { // 必须操作
                nums[i + 1] = nums[i + 1] xor 1
                nums[i + 2] = nums[i + 2] xor 1
                ans++
            }
        }
        return if (nums[n - 2] != 0 && nums[n - 1] != 0) ans else -1
    }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3192

> <p>给你一个二进制数组&nbsp;<code>nums</code>&nbsp;。</p>
> 
> <p>你可以对数组执行以下操作&nbsp;<strong>任意</strong>&nbsp;次（也可以 0 次）：</p>
> 
> <ul>
> 	<li>选择数组中 <strong>任意</strong>&nbsp;一个下标 <code>i</code>&nbsp;，并将从下标 <code>i</code>&nbsp;开始一直到数组末尾 <strong>所有</strong>&nbsp;元素 <strong>反转</strong>&nbsp;。</li>
> </ul>
> 
> <p><b>反转</b>&nbsp;一个元素指的是将它的值从 0 变 1 ，或者从 1 变 0 。</p>
> 
> <p>请你返回将 <code>nums</code>&nbsp;中所有元素变为 1 的 <strong>最少</strong>&nbsp;操作次数。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [0,1,1,0,1]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>4</span></p>
> 
> <p><strong>解释：</strong><br />
> 我们可以执行以下操作：</p>
> 
> <ul>
> 	<li>选择下标&nbsp;<code>i = 1</code>&nbsp;执行操作，得到<span class="example-io">&nbsp;<code>nums = [0,<u><strong>0</strong></u>,<u><strong>0</strong></u>,<u><strong>1</strong></u>,<u><strong>0</strong></u>]</code>&nbsp;。</span></li>
> 	<li>选择下标&nbsp;<code>i = 0</code>&nbsp;执行操作，得到<span class="example-io">&nbsp;<code>nums = [<u><strong>1</strong></u>,<u><strong>1</strong></u>,<u><strong>1</strong></u>,<u><strong>0</strong></u>,<u><strong>1</strong></u>]</code>&nbsp;。</span></li>
> 	<li>选择下标&nbsp;<code>i = 4</code>&nbsp;执行操作，得到<span class="example-io">&nbsp;<code>nums = [1,1,1,0,<u><strong>0</strong></u>]</code>&nbsp;。</span></li>
> 	<li>选择下标&nbsp;<code>i = 3</code>&nbsp;执行操作，得到<span class="example-io">&nbsp;<code>nums = [1,1,1,<u><strong>1</strong></u>,<u><strong>1</strong></u>]</code>&nbsp;。</span></li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,0,0,0]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong><br />
> 我们可以执行以下操作：</p>
> 
> <ul>
> 	<li>选择下标&nbsp;<code>i = 1</code>&nbsp;执行操作，得到<span class="example-io">&nbsp;<code>nums = [1,<u><strong>1</strong></u>,<u><strong>1</strong></u>,<u><strong>1</strong></u>]</code>&nbsp;。</span></li>
> </ul>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= nums[i] &lt;= 1</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d19;

/*
 * https://leetcode.cn/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-ii/description/
 * */
class LC3192 {

  public int minOperations(int[] nums) {
    var ans = 0;
    for (int num : nums) {
      if (((ans & 1) ^ num) == 0) {
        ans++;
      }
    }
    return ans;
  }
}
```
</li>
<li>kotlin solution

```kotlin
package com.hyperboat.daily.y2024.m10.d19

internal class Solution {
    fun minOperations(nums: IntArray): Int {
        val n = nums.size
        var ans = 0
        for (i in 0 until n) {
            if (ans and 1 xor nums[i] == 0) {
                ans++
            }
        }
        return ans
    }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>最小差值 I

> <p>给你一个整数数组 <code>nums</code>，和一个整数 <code>k</code> 。</p>
> 
> <p>在一个操作中，您可以选择 <code>0 &lt;= i &lt; nums.length</code> 的任何索引 <code>i</code> 。将 <code>nums[i]</code> 改为 <code>nums[i] + x</code> ，其中 <code>x</code> 是一个范围为 <code>[-k, k]</code> 的整数。对于每个索引 <code>i</code> ，最多 <strong>只能 </strong>应用 <strong>一次</strong> 此操作。</p>
> 
> <p><code>nums</code>&nbsp;的&nbsp;<strong>分数&nbsp;</strong>是&nbsp;<code>nums</code>&nbsp;中最大和最小元素的差值。&nbsp;</p>
> 
> <p><em>在对&nbsp; <code>nums</code> 中的每个索引最多应用一次上述操作后，返回&nbsp;<code>nums</code> 的最低 <strong>分数</strong></em> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1], k = 0
> <strong>输出：</strong>0
> <strong>解释：</strong>分数是 max(nums) - min(nums) = 1 - 1 = 0。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [0,10], k = 2
> <strong>输出：</strong>6
> <strong>解释：</strong>将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1,3,6], k = 3
> <strong>输出：</strong>0
> <strong>解释：</strong>将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
> 	<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
> 	<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d20;

/**
 * 908. 最小差值 I
 * <p>
 * https://leetcode.cn/problems/smallest-range-i/description/
 */
class LC908 {

  public int smallestRangeI(int[] nums, int k) {
    var max = 0;
    var min = 10000;
    for (int x : nums) {
      max = Math.max(x, max);
      min = Math.min(x, min);
    }
    var score = max - min - k * 2;
    return Math.max(score, 0);
  }
}
```
</li>
<li>kotlin solution

```kotlin
package com.hyperboat.daily.y2024.m10.d20

import kotlin.math.max

class Solution {
    fun smallestRangeI(nums: IntArray, k: Int): Int {
        return max(nums.max()-nums.min()-k*2,0)
    }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>最小差值 II

> <p>给你一个整数数组 <code>nums</code>，和一个整数&nbsp;<code>k</code> 。</p>
> 
> <p>对于每个下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），将 <code>nums[i]</code> 变成<strong> </strong> <code>nums[i] + k</code> 或 <code>nums[i] - k</code> 。</p>
> 
> <p><code>nums</code> 的 <strong>分数</strong> 是 <code>nums</code> 中最大元素和最小元素的差值。</p>
> 
> <p>在更改每个下标对应的值之后，返回 <code>nums</code> 的最小 <strong>分数</strong> 。</p>
> 
> <p>&nbsp;</p>
> 
> <ol>
> </ol>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1], k = 0
> <strong>输出：</strong>0
> <strong>解释：</strong>分数 = max(nums) - min(nums) = 1 - 1 = 0 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [0,10], k = 2
> <strong>输出：</strong>6
> <strong>解释：</strong>将数组变为 [2, 8] 。分数 = max(nums) - min(nums) = 8 - 2 = 6 。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1,3,6], k = 3
> <strong>输出：</strong>3
> <strong>解释：</strong>将数组变为 [4, 6, 3] 。分数 = max(nums) - min(nums) = 6 - 3 = 3 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>
> 	<li><code>0 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
> 	<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m10.d21;

import java.util.Arrays;

public class LC910 {

  public int smallestRangeII(int[] nums, int k) {
    var n = nums.length;
    Arrays.sort(nums);
    var ans = nums[n - 1] - nums[0];
    for (var i = 0; i < n - 1; i++) {
      var x = nums[i];
      var y = nums[i + 1];
      var max = Math.max(nums[n - 1] - k, x + k);
      var min = Math.min(nums[0] + k, y - k);
      ans = Math.min(ans, max - min);
    }
    return ans;
  }
}
```
</li>
<li>kotlin solution

```kotlin
package com.hyperboat.daily.y2024.m10.d21

import java.util.*

internal class Solution {
    fun smallestRangeII(nums: IntArray, k: Int): Int {
        val n = nums.size
        Arrays.sort(nums)
        var ans = nums[n - 1] - nums[0]
        for (i in 0 until n - 1) {
            val x = nums[i]
            val y = nums[i + 1]
            val max = (nums[n - 1] - k).coerceAtLeast(x + k)
            val min = (nums[0] + k).coerceAtMost(y - k)
            ans = ans.coerceAtMost(max - min)
        }
        return ans
    }
}
```
</li>
</ul>
</li>
</ol>
