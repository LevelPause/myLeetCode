<ol>
<li>
<ul>
<li>在既定时间做作业的学生人数

> <p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>
> 
> <p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>
> 
> <p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><strong>输入：</strong>startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
> <strong>输出：</strong>1
> <strong>解释：</strong>一共有 3 名学生。
> 第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。
> 第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。
> 第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 4
> <strong>输出：</strong>1
> <strong>解释：</strong>在查询时间只有一名学生在做作业。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre><strong>输入：</strong>startTime = [4], endTime = [4], queryTime = 5
> <strong>输出：</strong>0
> </pre>
> 
> <p><strong>示例 4：</strong></p>
> 
> <pre><strong>输入：</strong>startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
> <strong>输出：</strong>0
> </pre>
> 
> <p><strong>示例 5：</strong></p>
> 
> <pre><strong>输入：</strong>startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
> <strong>输出：</strong>5
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>startTime.length == endTime.length</code></li>
> 	<li><code>1 &lt;= startTime.length &lt;= 100</code></li>
> 	<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>
> 	<li><code>1 &lt;=&nbsp;queryTime &lt;= 1000</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d01;

class LC1450 {

  class Solution {

    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {
      int n = startTime.length;
      int ans = 0;

      for (int i = 0; i < n; i++) {
        if (startTime[i] <= queryTime && endTime[i] >= queryTime) {
          ans++;
        }
      }

      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>考试的最大困扰度

> <p>一位老师正在出一场由 <code>n</code>&nbsp;道判断题构成的考试，每道题的答案为 true （用 <code><span style="">'T'</span></code> 表示）或者 false （用 <code>'F'</code>&nbsp;表示）。老师想增加学生对自己做出答案的不确定性，方法是&nbsp;<strong>最大化&nbsp;</strong>有 <strong>连续相同</strong>&nbsp;结果的题数。（也就是连续出现 true 或者连续出现 false）。</p>
> 
> <p>给你一个字符串&nbsp;<code>answerKey</code>&nbsp;，其中&nbsp;<code>answerKey[i]</code>&nbsp;是第 <code>i</code>&nbsp;个问题的正确结果。除此以外，还给你一个整数 <code>k</code>&nbsp;，表示你能进行以下操作的最多次数：</p>
> 
> <ul>
> 	<li>每次操作中，将问题的正确答案改为&nbsp;<code>'T'</code> 或者&nbsp;<code>'F'</code>&nbsp;（也就是将 <code>answerKey[i]</code> 改为&nbsp;<code>'T'</code>&nbsp;或者&nbsp;<code>'F'</code>&nbsp;）。</li>
> </ul>
> 
> <p>请你返回在不超过 <code>k</code>&nbsp;次操作的情况下，<strong>最大</strong>&nbsp;连续 <code>'T'</code>&nbsp;或者 <code>'F'</code>&nbsp;的数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>answerKey = "TTFF", k = 2
> <b>输出：</b>4
> <b>解释：</b>我们可以将两个 'F' 都变为 'T' ，得到 answerKey = "<em><strong>TTTT</strong></em>" 。
> 总共有四个连续的 'T' 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>answerKey = "TFFT", k = 1
> <b>输出：</b>3
> <b>解释：</b>我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = "<em><strong>FFF</strong></em>T" 。
> 或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = "T<em><strong>FFF</strong></em>" 。
> 两种情况下，都有三个连续的 'F' 。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <b>输入：</b>answerKey = "TTFTTFTT", k = 1
> <b>输出：</b>5
> <b>解释：</b>我们可以将第一个 'F' 换成 'T' ，得到 answerKey = "<em><strong>TTTTT</strong></em>FTT" 。
> 或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = "TTF<em><strong>TTTTT</strong></em>" 。
> 两种情况下，都有五个连续的 'T' 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>n == answerKey.length</code></li>
> 	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>answerKey[i]</code>&nbsp;要么是&nbsp;<code>'T'</code> ，要么是&nbsp;<code>'F'</code></li>
> 	<li><code>1 &lt;= k &lt;= n</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d02;

class LC2024 {

  class Solution {

    public int maxConsecutiveAnswers(String answerKey, int k) {
      return Math.max(getCnt('T', answerKey, k), getCnt('F', answerKey, k));
    }

    private int getCnt(char c, String s, int k) {
      int n = s.length();
      int l = 0, r = 0;
      int cntC = 0;
      int len = 0;
      while (r < n) {
        if (s.charAt(r) == c) {
          cntC++;
        }
        while (l < r && cntC > k) {
          if (s.charAt(l++) == c) {
            cntC--;
            break;
          }
        }
        len = Math.max(len, r - l + 1);
        r++;
      }
      return len;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>一个小组的最大实力值

> <p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个 <strong>非空</strong>&nbsp;小组，且这个小组的 <strong>实力值</strong>&nbsp;最大，如果这个小组里的学生下标为&nbsp;<code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, ... , <code>i<sub>k</sub></code>&nbsp;，那么这个小组的实力值定义为&nbsp;<code>nums[i<sub>0</sub>] * nums[i<sub>1</sub>] * nums[i<sub>2</sub>] * ... * nums[i<sub>k</sub>​]</code>&nbsp;。</p>
> 
> <p>请你返回老师创建的小组能得到的最大实力值为多少。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><b>输入：</b>nums = [3,-1,-5,2,5,-9]
> <strong>输出：</strong>1350
> <b>解释：</b>一种构成最大实力值小组的方案是选择下标为 [0,2,3,4,5] 的学生。实力值为 3 * (-5) * 2 * 5 * (-9) = 1350 ，这是可以得到的最大实力值。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><b>输入：</b>nums = [-4,-5,-4]
> <b>输出：</b>20
> <b>解释：</b>选择下标为 [0, 1] 的学生。得到的实力值为 20 。我们没法得到更大的实力值。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 13</code></li>
> 	<li><code>-9 &lt;= nums[i] &lt;= 9</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d03;

class LC2708 {

  class Solution {

    public long maxStrength(int[] nums) {
      return dp(nums);
    }

    public long dp(int[] nums) {
      int n = nums.length;
      long fMax = nums[0];
      long fMin = nums[0];
      for (int i = 1; i < n; i++) {
        int x = nums[i];
        long t = fMax;
        fMax = Math.max(Math.max(x * fMin, x * fMax), Math.max(fMax, x * fMax));
        fMin = Math.min(Math.min(x * fMin, x * t), Math.min(fMin, x * fMin));
      }
      return fMax;
    }

  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>让所有学生保持开心的分组方法数

> <p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>n</code> 是班级中学生的总数。班主任希望能够在让所有学生保持开心的情况下选出一组学生：</p>
> 
> <p>如果能够满足下述两个条件之一，则认为第 <code>i</code> 位学生将会保持开心：</p>
> 
> <ul>
> 	<li>这位学生被选中，并且被选中的学生人数 <strong>严格大于</strong> <code>nums[i]</code> 。</li>
> 	<li>这位学生没有被选中，并且被选中的学生人数 <strong>严格小于</strong> <code>nums[i]</code> 。</li>
> </ul>
> 
> <p>返回能够满足让所有学生保持开心的分组方法的数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1,1]
> <strong>输出：</strong>2
> <strong>解释：</strong>
> 有两种可行的方法：
> 班主任没有选中学生。
> 班主任选中所有学生形成一组。 
> 如果班主任仅选中一个学生来完成分组，那么两个学生都无法保持开心。因此，仅存在两种可行的方法。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [6,0,3,3,6,7,2,7]
> <strong>输出：</strong>3
> <strong>解释：</strong>
> 存在三种可行的方法：
> 班主任选中下标为 1 的学生形成一组。
> 班主任选中下标为 1、2、3、6 的学生形成一组。
> 班主任选中所有学生形成一组。 
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d04;

import java.util.Comparator;
import java.util.List;

class LC2860 {

  class Solution {


    public int countWays(List<Integer> nums) {
      nums.sort(Comparator.comparingInt(o -> o));
      int ans = nums.get(0) == 0 ? 1 : 0;
      for (int i = 1; i < nums.size(); i++) {
        if (nums.get(i - 1) < i && i < nums.get(i)) {
          ans++;
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3174

> <p>给你一个字符串&nbsp;<code>s</code>&nbsp;。</p>
> 
> <p>你的任务是重复以下操作删除 <strong>所有</strong>&nbsp;数字字符：</p>
> 
> <ul>
> 	<li>删除 <strong>第一个数字字符</strong>&nbsp;以及它左边 <strong>最近</strong>&nbsp;的 <strong>非数字</strong>&nbsp;字符。</li>
> </ul>
> 
> <p>请你返回删除所有数字字符以后剩下的字符串。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>s = "abc"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>"abc"</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>字符串中没有数字。<!-- notionvc: ff07e34f-b1d6-41fb-9f83-5d0ba3c1ecde --></p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>s = "cb34"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>""</span></p>
> 
> <p><b>解释：</b></p>
> 
> <p>一开始，我们对&nbsp;<code>s[2]</code>&nbsp;执行操作，<code>s</code>&nbsp;变为&nbsp;<code>"c4"</code>&nbsp;。</p>
> 
> <p>然后对&nbsp;<code>s[1]</code>&nbsp;执行操作，<code>s</code>&nbsp;变为&nbsp;<code>""</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 100</code></li>
> 	<li><code>s</code>&nbsp;只包含小写英文字母和数字字符。</li>
> 	<li>输入保证所有数字都可以按以上操作被删除。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d05;

class LC3174 {

  class Solution {

    public String clearDigits(String s) {
      char[] chars = s.toCharArray();
      StringBuilder sb = new StringBuilder();
      for (char c : chars) {
        if (Character.isDigit(c) && sb.length() > 0) {
          sb.deleteCharAt(sb.length() - 1);
        } else {
          sb.append(c);
        }
      }
      return sb.toString();
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3176

> <p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>非负</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。如果一个整数序列&nbsp;<code>seq</code>&nbsp;满足在下标范围&nbsp;<code>[0, seq.length - 2]</code>&nbsp;中&nbsp;<strong>最多只有</strong>&nbsp;<code>k</code>&nbsp;个下标 <code>i</code>&nbsp;满足&nbsp;<code>seq[i] != seq[i + 1]</code>&nbsp;，那么我们称这个整数序列为&nbsp;<strong>好</strong>&nbsp;序列。</p>
> 
> <p>请你返回 <code>nums</code>&nbsp;中&nbsp;<strong>好</strong> <span data-keyword="subsequence-array">子序列</span>&nbsp;的最长长度。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,1,1,3], k = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>4</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>最长好子序列为&nbsp;<code>[<u>1</u>,<u>2</u>,<u>1</u>,<u>1</u>,3]</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,3,4,5,1], k = 0</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>最长好子序列为&nbsp;<code>[<u>1</u>,2,3,4,5,<u>1</u>]</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 500</code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= k &lt;= min(nums.length, 25)</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d06;

class LC3176 {

  class Solution {

    public int maximumLength(int[] nums, int k) {
      int ans = 0;
      int n = nums.length;
      int l = 0;
      int cnt = 0;
      for (int r = 0; r < n - 1; r++) {
        if (nums[r] != nums[r + 1]) {
          cnt++;
        }
        while (cnt > k && l < r) {
          l++;
          if (nums[l - 1] != nums[l]) {
            cnt--;
            ans = Math.max(ans, r - l + 2);
            break;
          }
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3177

> <p>给你一个整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>非负</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。如果一个整数序列&nbsp;<code>seq</code>&nbsp;满足在范围下标范围&nbsp;<code>[0, seq.length - 2]</code>&nbsp;中存在 <strong>不超过</strong>&nbsp;<code>k</code>&nbsp;个下标 <code>i</code>&nbsp;满足&nbsp;<code>seq[i] != seq[i + 1]</code>&nbsp;，那么我们称这个整数序列为&nbsp;<strong>好</strong>&nbsp;序列。</p>
> 
> <p>请你返回 <code>nums</code>&nbsp;中&nbsp;<strong>好</strong> <span data-keyword="subsequence-array">子序列</span>&nbsp;的最长长度</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,1,1,3], k = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>4</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>最长好子序列为&nbsp;<code>[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<strong><em>1</em></strong>,<em><strong>1</strong></em>,3]</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,3,4,5,1], k = 0</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>最长好子序列为&nbsp;<code>[<strong><em>1</em></strong>,2,3,4,5,<strong><em>1</em></strong>]</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>3</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= k &lt;= min(50, nums.length)</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d07;

class LC3177 {

  class Solution {

    public int maximumLength(int[] nums, int k) {
      int ans = 0;
      int n = nums.length;
      int l = 0;
      int cnt = 0;
      for (int r = 0; r < n - 1; r++) {
        if (nums[r] != nums[r + 1]) {
          cnt++;
        }
        while (cnt > k && l < r) {
          l++;
          if (nums[l - 1] != nums[l]) {
            cnt--;
            ans = Math.max(ans, r - l + 2);
            break;
          }
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>有序数组的平方

> <p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
> 
> <ul>
> </ul>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [-4,-1,0,3,10]
> <strong>输出：</strong>[0,1,9,16,100]
> <strong>解释：</strong>平方后，数组变为 [16,1,0,9,100]
> 排序后，数组变为 [0,1,9,16,100]</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [-7,-3,2,3,11]
> <strong>输出：</strong>[4,9,9,49,121]
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code><span>1 <= nums.length <= </span>10<sup>4</sup></code></li>
> 	<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>
> 	<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
> </ul>
> 
> <p> </p>
> 
> <p><strong>进阶：</strong></p>
> 
> <ul>
> 	<li>请你<span style="color: rgb(36, 41, 46); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</span></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d08;

class LC977 {

  class Solution {

    public int[] sortedSquares(int[] nums) {
      return doublePointer1(nums);
    }

    public int[] doublePointer1(int[] nums) {
      int n = nums.length;
      int[] ans = new int[n];
      int l = 0, r = n - 1, pos = n - 1;
      while (l <= r) {
        int left = nums[l] * nums[l];
        int right = nums[r] * nums[r];
        if (left > right) {
          ans[pos--] = left;
          l++;
        } else {
          ans[pos--] = right;
          r--;
        }
      }
      return ans;
    }

    public int[] doublePointer2(int[] nums) {
      int n = nums.length;
      int[] ans = new int[n];
      if (nums[0] >= 0) {
        for (int i = 0; i < ans.length; i++) {
          ans[i] = nums[i] * nums[i];
        }
        return ans;
      }
      int r = 0;
      while (r < n && nums[r] < 0) {
        r++;
      }
      int l = r - 1;
      int index = 0;
      while (l >= 0 || r < n) {
        if (l < 0) {
          ans[index++] = nums[r] * nums[r++];
          continue;
        }
        if (r >= n) {
          ans[index++] = nums[l] * nums[l--];
          continue;
        }
        if (nums[l] * nums[l] < nums[r] * nums[r]) {
          ans[index++] = nums[l] * nums[l--];
        } else {
          ans[index++] = nums[r] * nums[r++];
        }
      }
      return ans;

    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>合并零之间的节点

> <p>给你一个链表的头节点 <code>head</code> ，该链表包含由 <code>0</code> 分隔开的一连串整数。链表的 <strong>开端</strong> 和 <strong>末尾</strong> 的节点都满足 <code>Node.val == 0</code> 。</p>
> 
> <p>对于每两个相邻的 <code>0</code> ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 <code>0</code> 移除，修改后的链表不应该含有任何 <code>0</code> 。</p>
> 
> <p>&nbsp;返回修改后链表的头节点 <code>head</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：<br />
> <img alt="" src="https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png" style="width: 600px; height: 41px;" /></strong></p>
> 
> <pre>
> <strong>输入：</strong>head = [0,3,1,0,4,5,2,0]
> <strong>输出：</strong>[4,11]
> <strong>解释：</strong>
> 上图表示输入的链表。修改后的链表包含：
> - 标记为绿色的节点之和：3 + 1 = 4
> - 标记为红色的节点之和：4 + 5 + 2 = 11
> </pre>
> 
> <p><strong>示例 2：<br />
> <img alt="" src="https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png" style="width: 600px; height: 41px;" /></strong></p>
> 
> <pre>
> <strong>输入：</strong>head = [0,1,0,3,0,2,2,0]
> <strong>输出：</strong>[1,3,4]
> <strong>解释：</strong>
> 上图表示输入的链表。修改后的链表包含：
> - 标记为绿色的节点之和：1 = 1
> - 标记为红色的节点之和：3 = 3
> - 标记为黄色的节点之和：2 + 2 = 4
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li>列表中的节点数目在范围 <code>[3, 2 * 10<sup>5</sup>]</code> 内</li>
> 	<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
> 	<li><strong>不</strong> 存在连续两个&nbsp;<code>Node.val == 0</code> 的节点</li>
> 	<li>链表的 <strong>开端</strong> 和 <strong>末尾</strong> 节点都满足 <code>Node.val == 0</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d09;

class LC2181 {

  class Solution {

    public ListNode mergeNodes(ListNode head) {
      int sum = 0;
      ListNode dummy = new ListNode(0);
      ListNode curr = dummy;
      head = head.next;
      while (head != null) {
        sum += head.val;
        if (head.val == 0) {
          curr.next = new ListNode(sum);
          curr = curr.next;
          sum = 0;
        }
        head = head.next;
      }
      return dummy.next;
    }

    //原地修改
    public ListNode mergeNodes2(ListNode head) {
      ListNode tail = head;
      ListNode curr = head.next;
      while (curr.next != null) {
        if (curr.val != 0) {
          tail.val += curr.val;
        } else {
          tail = tail.next;
          tail.val = 0;
        }
        curr = curr.next;
      }
      tail.next = null;
      return head;
    }
  }


  class ListNode {

    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
      this.val = val;
    }

    ListNode(int val, ListNode next) {
      this.val = val;
      this.next = next;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>统计上升四元组

> <p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，它包含&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的所有数字，请你返回上升四元组的数目。</p>
> 
> <p>如果一个四元组&nbsp;<code>(i, j, k, l)</code>&nbsp;满足以下条件，我们称它是上升的：</p>
> 
> <ul>
> 	<li><code>0 &lt;= i &lt; j &lt; k &lt; l &lt; n</code>&nbsp;且</li>
> 	<li><code>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l]</code>&nbsp;。</li>
> </ul>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><b>输入：</b>nums = [1,3,2,4,5]
> <b>输出：</b>2
> <b>解释：</b>
> - 当 i = 0 ，j = 1 ，k = 2 且 l = 3 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。
> - 当 i = 0 ，j = 1 ，k = 2 且 l = 4 时，有 nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l] 。
> 没有其他的四元组，所以我们返回 2 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><b>输入：</b>nums = [1,2,3,4]
> <b>输出：</b>0
> <b>解释：</b>只存在一个四元组 i = 0 ，j = 1 ，k = 2 ，l = 3 ，但是 nums[j] &lt; nums[k] ，所以我们返回 0 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>4 &lt;= nums.length &lt;= 4000</code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>
> 	<li><code>nums</code>&nbsp;中所有数字 <strong>互不相同</strong>&nbsp;，<code>nums</code>&nbsp;是一个排列。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d10;

class LC2552 {

  class Solution {

    public long countQuadruplets(int[] nums) {
      long ans = 0L;
      int n = nums.length;
      int[] pre = new int[n + 1];
      for (int j = 0; j < n; j++) {
        int cnt = 0;

        for (int k = n - 1; k > j; k--) {
          if (nums[j] > nums[k]) {
            ans += (long) pre[nums[k]] * cnt;
          } else {
            cnt++;
          }
        }
        for (int i = nums[j] + 1; i <= n; i++) {
          pre[i]++;
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>两个线段获得的最多奖品

> <p>在 <strong>X轴</strong>&nbsp;上有一些奖品。给你一个整数数组&nbsp;<code>prizePositions</code>&nbsp;，它按照 <strong>非递减</strong>&nbsp;顺序排列，其中&nbsp;<code>prizePositions[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数&nbsp;<code>k</code>&nbsp;。</p>
> 
> <p>你可以选择两个端点为整数的线段。每个线段的长度都必须是 <code>k</code>&nbsp;。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。</p>
> 
> <ul>
> 	<li>比方说&nbsp;<code>k = 2</code>&nbsp;，你可以选择线段&nbsp;<code>[1, 3]</code> 和&nbsp;<code>[2, 4]</code>&nbsp;，你可以获得满足&nbsp;<code>1 &lt;= prizePositions[i] &lt;= 3</code> 或者&nbsp;<code>2 &lt;= prizePositions[i] &lt;= 4</code>&nbsp;的所有奖品 i 。</li>
> </ul>
> 
> <p>请你返回在选择两个最优线段的前提下，可以获得的 <strong>最多</strong>&nbsp;奖品数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>prizePositions = [1,1,2,2,3,3,5], k = 2
> <b>输出：</b>7
> <b>解释：</b>这个例子中，你可以选择线段 [1, 3] 和 [3, 5] ，获得 7 个奖品。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>prizePositions = [1,2,3,4], k = 0
> <b>输出：</b>2
> <b>解释：</b>这个例子中，一个选择是选择线段 <code>[3, 3]</code> 和 <code>[4, 4] ，获得 2 个奖品。</code>
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= prizePositions.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= prizePositions[i] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= k &lt;= 10<sup>9</sup> </code></li>
> 	<li><code>prizePositions</code>&nbsp;有序非递减。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d11;

/*
 * https://leetcode.cn/problems/maximize-win-from-two-segments/description/
 * */
class LC2555 {

  class Solution {

    public int maximizeWin(int[] prizePositions, int k) {
      int n = prizePositions.length;
      if (k * 2 + 1 >= prizePositions[n - 1] - prizePositions[0]) {
        return n;
      }
      int ans = 0;
      int left = 0;
      int[] mx = new int[n + 1];
      for (int right = 0; right < n; right++) {
        while (prizePositions[right] - prizePositions[left] > k) {
          left++;
        }
        ans = Math.max(ans, mx[left] + right - left + 1);
        mx[right + 1] = Math.max(mx[right], right - left + 1);
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>求出最多标记下标

> <p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;。</p>
> 
> <p>一开始，所有下标都没有被标记。你可以执行以下操作任意次：</p>
> 
> <ul>
> 	<li>选择两个 <strong>互不相同且未标记</strong>&nbsp;的下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;，满足&nbsp;<code>2 * nums[i] &lt;= nums[j]</code>&nbsp;，标记下标&nbsp;<code>i</code> 和&nbsp;<code>j</code>&nbsp;。</li>
> </ul>
> 
> <p>请你执行上述操作任意次，返回<em>&nbsp;</em><code>nums</code>&nbsp;中最多可以标记的下标数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>nums = [3,5,2,4]
> <b>输出：</b>2
> <strong>解释：</strong>第一次操作中，选择 i = 2 和 j = 1 ，操作可以执行的原因是 2 * nums[2] &lt;= nums[1] ，标记下标 2 和 1 。
> 没有其他更多可执行的操作，所以答案为 2 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>nums = [9,2,5,4]
> <b>输出：</b>4
> <strong>解释：</strong>第一次操作中，选择 i = 3 和 j = 0 ，操作可以执行的原因是 2 * nums[3] &lt;= nums[0] ，标记下标 3 和 0 。
> 第二次操作中，选择 i = 1 和 j = 2 ，操作可以执行的原因是 2 * nums[1] &lt;= nums[2] ，标记下标 1 和 2 。
> 没有其他更多可执行的操作，所以答案为 4 。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <b>输入：</b>nums = [7,6,8]
> <b>输出：</b>0
> <strong>解释：</strong>没有任何可以执行的操作，所以答案为 0 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d12;

import java.util.Arrays;

/*
 * https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description/
 * */
class LC2576 {

  class Solution {

    public int maxNumOfMarkedIndices(int[] nums) {
      Arrays.sort(nums);
      int l = 0;
      int n = nums.length;
      for (int r = (n + 1) / 2; r < n; r++) {
        if (nums[l] * 2 <= nums[r]) {
          l++;
        }
      }
      return l * 2;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>预算内的最多机器人数目

> <p>你有&nbsp;<code>n</code>&nbsp;个机器人，给你两个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>chargeTimes</code> 和&nbsp;<code>runningCosts</code>&nbsp;，两者长度都为&nbsp;<code>n</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个机器人充电时间为&nbsp;<code>chargeTimes[i]</code>&nbsp;单位时间，花费&nbsp;<code>runningCosts[i]</code>&nbsp;单位时间运行。再给你一个整数&nbsp;<code>budget</code>&nbsp;。</p>
> 
> <p>运行&nbsp;<code>k</code>&nbsp;个机器人 <strong>总开销</strong>&nbsp;是&nbsp;<code>max(chargeTimes) + k * sum(runningCosts)</code>&nbsp;，其中&nbsp;<code>max(chargeTimes)</code>&nbsp;是这&nbsp;<code>k</code>&nbsp;个机器人中最大充电时间，<code>sum(runningCosts)</code>&nbsp;是这 <code>k</code>&nbsp;个机器人的运行时间之和。</p>
> 
> <p>请你返回在 <strong>不超过</strong>&nbsp;<code>budget</code>&nbsp;的前提下，你 <strong>最多</strong>&nbsp;可以 <strong>连续</strong>&nbsp;运行的机器人数目为多少。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25
> <b>输出：</b>3
> <b>解释：</b>
> 可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。
> 选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。
> 可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19
> <b>输出：</b>0
> <b>解释：</b>即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>chargeTimes.length == runningCosts.length == n</code></li>
> 	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= budget &lt;= 10<sup>15</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d13;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.PriorityQueue;

/*
 * https://leetcode.cn/problems/maximum-number-of-robots-within-budget/
 * */
class LC2398 {

  class Solution {

    public int maximumRobots(int[] chargeTimes, int[] runningCosts, long budget) {
      int n = chargeTimes.length;
      long cost;
      int ans = 0;
      long sum = 0;
      int max;
      int l = 0;
      PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> o2 - o1);
      for (int r = 0; r < n; r++) {

        pq.offer(chargeTimes[r]);
        max = pq.peek();
        sum += runningCosts[r];
        cost = (long) max + (r - l + 1) * sum;
        if (cost <= budget) {
          ans = Math.max(ans, r - l + 1);
        }
        while (l <= r && cost > budget) {
          pq.remove(chargeTimes[l]);
          max = pq.isEmpty() ? 0 : pq.peek();
          sum -= runningCosts[l];
          l++;
          cost = (long) max + (r - l + 1) * sum;
        }
      }
      return ans;
    }

    private int queue(int[] chargeTimes, int[] runningCosts, long budget) {
      int n = chargeTimes.length;
      long sum = 0;
      int l = 0;
      int ans = 0;
      Deque<Integer> dq = new ArrayDeque<>();
      for (int r = 0; r < n; r++) {
        while (!dq.isEmpty() && chargeTimes[r] >= chargeTimes[dq.peekLast()]) {
          dq.pollLast();
        }
        dq.addLast(r);
        sum += runningCosts[r];
        while (!dq.isEmpty() && chargeTimes[dq.peekFirst()] + sum * (r - l + 1) > budget) {
          if (dq.peekFirst() == l) {
            dq.pollFirst();
          }
          sum -= runningCosts[l++];
        }
        ans = Math.max(ans, r - l + 1);
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>从字符串中移除星号

> <p>给你一个包含若干星号 <code>*</code> 的字符串 <code>s</code> 。</p>
> 
> <p>在一步操作中，你可以：</p>
> 
> <ul>
> 	<li>选中 <code>s</code> 中的一个星号。</li>
> 	<li>移除星号 <strong>左侧</strong> 最近的那个 <strong>非星号</strong> 字符，并移除该星号自身。</li>
> </ul>
> 
> <p>返回移除 <strong>所有</strong> 星号之后的字符串<strong>。</strong></p>
> 
> <p><strong>注意：</strong></p>
> 
> <ul>
> 	<li>生成的输入保证总是可以执行题面中描述的操作。</li>
> 	<li>可以证明结果字符串是唯一的。</li>
> </ul>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "leet**cod*e"
> <strong>输出：</strong>"lecoe"
> <strong>解释：</strong>从左到右执行移除操作：
> - 距离第 1 个星号最近的字符是 "lee<em><strong>t</strong></em>**cod*e" 中的 't' ，s 变为 "lee*cod*e" 。
> - 距离第 2 个星号最近的字符是 "le<em><strong>e</strong></em>*cod*e" 中的 'e' ，s 变为 "lecod*e" 。
> - 距离第 3 个星号最近的字符是 "leco<em><strong>d</strong></em>*e" 中的 'd' ，s 变为 "lecoe" 。
> 不存在其他星号，返回 "lecoe" 。</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "erase*****"
> <strong>输出：</strong>""
> <strong>解释：</strong>整个字符串都会被移除，所以返回空字符串。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>s</code> 由小写英文字母和星号 <code>*</code> 组成</li>
> 	<li><code>s</code> 可以执行上述操作</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d14;

class LC2390 {

  class Solution {

    public String removeStars(String s) {
      StringBuilder sb = new StringBuilder(s.length());
      for (char c : s.toCharArray()) {
        if (c != '*') {
          sb.append(c);
        } else {
          sb.deleteCharAt(sb.length() - 1);
        }
      }
      return sb.toString();
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>与车相交的点

> <p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>nums</code> 表示汽车停放在数轴上的坐标。对于任意下标 <code>i</code>，<code>nums[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，其中 <code>start<sub>i</sub></code> 是第 <code>i</code> 辆车的起点，<code>end<sub>i</sub></code> 是第 <code>i</code> 辆车的终点。</p>
> 
> <p>返回数轴上被车 <strong>任意部分</strong> 覆盖的整数点的数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [[3,6],[1,5],[4,7]]
> <strong>输出：</strong>7
> <strong>解释：</strong>从 1 到 7 的所有点都至少与一辆车相交，因此答案为 7 。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [[1,3],[5,8]]
> <strong>输出：</strong>7
> <strong>解释：</strong>1、2、3、5、6、7、8 共计 7 个点满足至少与一辆车相交，因此答案为 7 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
> 	<li><code>nums[i].length == 2</code></li>
> 	<li><code><font face="monospace">1 &lt;= start<sub>i</sub>&nbsp;&lt;= end<sub>i</sub>&nbsp;&lt;= 100</font></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d15;

import java.util.List;

/*
 * https://leetcode.cn/problems/points-that-intersect-with-cars/
 * */
class LC2848 {

  class Solution {

    public int numberOfPoints(List<List<Integer>> nums) {
      int[] diff = new int[102];
      for (List<Integer> num : nums) {
        diff[num.get(0)]++;
        diff[num.get(1) + 1]--;
      }
      int ans = 0;
      int sum = 0;
      for (int i : diff) {
        sum += i;
        if (sum > 0) {
          ans++;
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>公交站间的距离

> <p>环形公交路线上有&nbsp;<code>n</code>&nbsp;个站，按次序从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;进行编号。我们已知每一对相邻公交站之间的距离，<code>distance[i]</code>&nbsp;表示编号为&nbsp;<code>i</code>&nbsp;的车站和编号为&nbsp;<code>(i + 1) % n</code>&nbsp;的车站之间的距离。</p>
> 
> <p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p>
> 
> <p>返回乘客从出发点&nbsp;<code>start</code>&nbsp;到目的地&nbsp;<code>destination</code>&nbsp;之间的最短距离。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg" style="height: 240px; width: 388px;"></p>
> 
> <pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 1
> <strong>输出：</strong>1
> <strong>解释：</strong>公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg" style="height: 240px; width: 388px;"></p>
> 
> <pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 2
> <strong>输出：</strong>3
> <strong>解释：</strong>公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 3：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg" style="height: 240px; width: 388px;"></p>
> 
> <pre><strong>输入：</strong>distance = [1,2,3,4], start = 0, destination = 3
> <strong>输出：</strong>4
> <strong>解释：</strong>公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n&nbsp;&lt;= 10^4</code></li>
> 	<li><code>distance.length == n</code></li>
> 	<li><code>0 &lt;= start, destination &lt; n</code></li>
> 	<li><code>0 &lt;= distance[i] &lt;= 10^4</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d16;

class LC1184 {

  class Solution {

    public int distanceBetweenBusStops(int[] distance, int start, int destination) {
      int n = distance.length;
      int ans = 0;
      int sum = 0;
      int cnt = n;
      boolean foundDes = false;
      while (cnt-- > 0) {
        if (start == destination) {
          foundDes = true;
        }
        if (!foundDes) {
          ans += distance[start];
        }
        sum += distance[start];
        start = (start + 1) % n;
      }
      return Math.min(ans, sum - ans);
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>公交路线

> <p>给你一个数组 <code>routes</code> ，表示一系列公交线路，其中每个 <code>routes[i]</code> 表示一条公交线路，第 <code>i</code> 辆公交车将会在上面循环行驶。</p>
> 
> <ul>
> 	<li>例如，路线 <code>routes[0] = [1, 5, 7]</code> 表示第 <code>0</code> 辆公交车会一直按序列 <code>1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...</code> 这样的车站路线行驶。</li>
> </ul>
> 
> <p>现在从 <code>source</code> 车站出发（初始时不在公交车上），要前往 <code>target</code> 车站。 期间仅可乘坐公交车。</p>
> 
> <p>求出 <strong>最少乘坐的公交车数量</strong> 。如果不可能到达终点车站，返回 <code>-1</code> 。</p>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>routes = [[1,2,7],[3,6,7]], source = 1, target = 6
> <strong>输出：</strong>2
> <strong>解释：</strong>最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
> <strong>输出：</strong>-1
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 <= routes.length <= 500</code>.</li>
> 	<li><code>1 <= routes[i].length <= 10<sup>5</sup></code></li>
> 	<li><code>routes[i]</code> 中的所有值 <strong>互不相同</strong></li>
> 	<li><code>sum(routes[i].length) <= 10<sup>5</sup></code></li>
> 	<li><code>0 <= routes[i][j] < 10<sup>6</sup></code></li>
> 	<li><code>0 <= source, target < 10<sup>6</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d17;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

class LC815 {

  static class Solution {

    public int numBusesToDestination(int[][] rs, int s, int t) {
      return s == t ? 0 : floyd(rs, s, t);
    }

    private int bfs(int[][] rs, int s, int t) {
      Map<Integer, List<Integer>> index = new HashMap<>();
      int n = rs.length;
      for (int i = 0; i < n; i++) {
        for (int x : rs[i]) {
          index.computeIfAbsent(x, k -> new ArrayList<>()).add(i);
        }
      }
      if (!index.containsKey(s) || !index.containsKey(t)) {
        return s == t ? 0 : -1;
      }
      Map<Integer, Integer> path = new HashMap<>();
      Deque<Integer> dq = new LinkedList<>();
      dq.offer(s);
      path.put(s, 0);
      while (!dq.isEmpty()) {
        int poll = dq.poll();
        int step = path.get(poll);
        List<Integer> line = index.get(poll);
        for (Integer x : line) {
          if (rs[x] != null) {
            for (int i : rs[x]) {
              if (!path.containsKey(i)) {
                path.put(i, step + 1);
                dq.offer(i);
              }
            }
            rs[x] = null;
          }
        }
      }
      return path.getOrDefault(t, -1);
    }

    private int floyd(int[][] rs, int s, int t) {

      // 记录某个车站可以进入的路线
      Map<Integer, List<Integer>> map = new HashMap<>();
      // 队列存的是经过的路线
      Deque<Integer> d = new ArrayDeque<>();
      int n = rs.length;
      for (int i = 0; i < n; i++) {
        for (int station : rs[i]) {
          // 将从起点可以进入的路线加入队列
          if (station == s) {
            d.addLast(i);
          }
          List<Integer> list = map.getOrDefault(station, new ArrayList<>());
          list.add(i);
          map.put(station, list);
        }
      }

      int[][] dist = new int[n][n];
      for (int[] line : dist) {
        Arrays.fill(line, Integer.MAX_VALUE / 2);

      }
      for (List<Integer> line : map.values()) {
        int size = line.size();
        for (int i = 0; i < size; i++) {
          for (int j = 0; j < size; j++) {
            int x = line.get(i);
            int y = line.get(j);
            dist[x][y] = i == j ? 0 : 1;
          }
        }
      }
      for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
            dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
          }
        }
      }
      System.out.println(Arrays.deepToString(dist));
      int ans = -1;
      List<Integer> sList = map.get(s);
      List<Integer> tList = map.get(t);
      if (sList == null || tList == null) {
        return ans;
      }
      for (Integer x : sList) {
        for (Integer y : tList) {
          if (dist[x][y] == Integer.MAX_VALUE / 2) {
            continue;
          }
          if (ans == -1) {
            ans = dist[x][y] + 1;
          } else {
            ans = Math.min(ans, dist[x][y] + 1);
          }
        }
      }
      return ans;
    }
  }

}
```
</li>
</ul>
</li>
<li>
<ul>
<li>坐上公交的最晚时间

> <p>给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>buses</code>&nbsp;，其中&nbsp;<code>buses[i]</code>&nbsp;表示第 <code>i</code>&nbsp;辆公交车的出发时间。同时给你一个下标从 <strong>0</strong>&nbsp;开始长度为 <code>m</code>&nbsp;的整数数组&nbsp;<code>passengers</code>&nbsp;，其中&nbsp;<code>passengers[j]</code>&nbsp;表示第&nbsp;<code>j</code>&nbsp;位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p>
> 
> <p>给你一个整数&nbsp;<code>capacity</code>&nbsp;，表示每辆公交车&nbsp;<strong>最多</strong>&nbsp;能容纳的乘客数目。</p>
> 
> <p>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code>&nbsp;时刻到达，公交在&nbsp;<code>x</code>&nbsp;时刻出发，满足&nbsp;<code>y &lt;= x</code>&nbsp;&nbsp;且公交没有满，那么你可以搭乘这一辆公交。<strong>最早</strong>&nbsp;到达的乘客优先上车。</p>
> 
> <p>返回你可以搭乘公交车的最晚到达公交站时间。你 <strong>不能</strong>&nbsp;跟别的乘客同时刻到达。</p>
> 
> <p><strong>注意：</strong>数组&nbsp;<code>buses</code> 和&nbsp;<code>passengers</code>&nbsp;不一定是有序的。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><b>输入：</b>buses = [10,20], passengers = [2,17,18,19], capacity = 2
> <b>输出：</b>16
> <strong>解释：</strong>
> 第 1 辆公交车载着第 1 位乘客。
> 第 2 辆公交车载着你和第 2 位乘客。
> 注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><b>输入：</b>buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2
> <b>输出：</b>20
> <b>解释：</b>
> 第 1 辆公交车载着第 4 位乘客。
> 第 2 辆公交车载着第 6 位和第 2 位乘客。
> 第 3 辆公交车载着第 1 位乘客和你。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>n == buses.length</code></li>
> 	<li><code>m == passengers.length</code></li>
> 	<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>
> 	<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>buses</code>&nbsp;中的元素 <strong>互不相同&nbsp;</strong>。</li>
> 	<li><code>passengers</code>&nbsp;中的元素 <strong>互不相同</strong>&nbsp;。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d18;

import java.util.Arrays;

class LC2332 {

  class Solution {

    public int latestTimeCatchTheBus(int[] b, int[] p, int cap) {
      Arrays.sort(b);
      Arrays.sort(p);
      int n = b.length;
      int m = p.length;
      int rest = cap;
      int j = 0;
      for (int k : b) {
        rest = cap;
        while (rest > 0 && j < m && k >= p[j]) {
          j++;
          rest--;
        }
      }
      j--;
      //先找到最后一个上车的乘客
      //如果最后一班车没满, 就从最后一班车的出发时刻往前遍历
      int ans = rest > 0 ? b[n - 1] : p[j];
      //往前找到没有乘客占据的时刻
      while (j >= 0 && ans == p[j]) {
        ans--;
        j--;
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>最长的字母序连续子字符串的长度

> <p><strong>字母序连续字符串</strong> 是由字母表中连续字母组成的字符串。换句话说，字符串 <code>"abcdefghijklmnopqrstuvwxyz"</code> 的任意子字符串都是 <strong>字母序连续字符串</strong> 。</p>
> 
> <ul>
> 	<li>例如，<code>"abc"</code> 是一个字母序连续字符串，而 <code>"acb"</code> 和 <code>"za"</code> 不是。</li>
> </ul>
> 
> <p>给你一个仅由小写英文字母组成的字符串 <code>s</code> ，返回其 <strong>最长</strong> 的 字母序连续子字符串 的长度。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><strong>输入：</strong>s = "abacaba"
> <strong>输出：</strong>2
> <strong>解释：</strong>共有 4 个不同的字母序连续子字符串 "a"、"b"、"c" 和 "ab" 。
> "ab" 是最长的字母序连续子字符串。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><strong>输入：</strong>s = "abcde"
> <strong>输出：</strong>5
> <strong>解释：</strong>"abcde" 是最长的字母序连续子字符串。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>s</code> 由小写英文字母组成</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d19;

/*
 * https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/
 * */
class LC2414 {

  class Solution {

    public int longestContinuousSubstring(String s) {
      int len = 1, ans = 1, n = s.length();
      char[] c = s.toCharArray();
      for (int i = 1; i < n; i++) {
        if (c[i - 1] + 1 == c[i]) {
          len++;
        } else {
          len = 1;
        }
        ans = Math.max(len, ans);
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>统计特殊整数

> <p>如果一个正整数每一个数位都是 <strong>互不相同</strong>&nbsp;的，我们称它是 <strong>特殊整数</strong> 。</p>
> 
> <p>给你一个 <strong>正</strong>&nbsp;整数&nbsp;<code>n</code>&nbsp;，请你返回区间<em>&nbsp;</em><code>[1, n]</code>&nbsp;之间特殊整数的数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>n = 20
> <b>输出：</b>19
> <b>解释：</b>1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>n = 5
> <b>输出：</b>5
> <b>解释：</b>1 到 5 所有整数都是特殊整数。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <b>输入：</b>n = 135
> <b>输出：</b>110
> <b>解释：</b>从 1 到 135 总共有 110 个整数是特殊整数。
> 不特殊的部分数字为：22 ，114 和 131 。</pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 2 * 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d20;

import java.util.Arrays;

class LC2376 {

  class Solution {

    private char[] arr;
    private int[][] memo;

    public int countSpecialNumbers(int n) {
      arr = Integer.toString(n).toCharArray();
      memo = new int[arr.length][1 << 10];
      for (int[] line : memo) {
        Arrays.fill(line, -1);
      }
      return dfs(0, 0, true, false);
    }

    private int dfs(int i, int mask, boolean isLimit, boolean isNum) {
      if (i == arr.length) {
        return isNum ? 1 : 0;
      }
      if (!isLimit && isNum && memo[i][mask] > 0) {
        return memo[i][mask];
      }
      int res = 0;
      //跳过当前数位
      if (!isNum) {
        res += dfs(i + 1, mask, false, false);
      }
      //枚举当前数位
      int up = isLimit ? arr[i] - '0' : 9;
      for (int j = isNum ? 0 : 1; j <= up; j++) {
        //没有枚举过这个数j
        if ((mask >> j & 1) == 0) {
          res += dfs(i + 1, mask | (1 << j), isLimit && j == up, true);
        }
      }
      if (!isLimit && isNum) {
        memo[i][mask] = res;
      }
      return res;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>边积分最高的节点

> <p>给你一个有向图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> ，其中每个节点都 <strong>恰有一条</strong> 出边。</p>
> 
> <p>图由一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 <strong>有向</strong> 边。</p>
> 
> <p>节点 <code>i</code> 的 <strong>边积分</strong> 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 <strong>编号</strong> 总和。</p>
> 
> <p>返回 <strong>边积分</strong> 最高的节点。如果多个节点的 <strong>边积分</strong> 相同，返回编号 <strong>最小</strong> 的那个。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> <img src="https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png" style="width: 450px; height: 260px;">
> <pre><strong>输入：</strong>edges = [1,0,0,0,0,7,7,5]
> <strong>输出：</strong>7
> <strong>解释：</strong>
> - 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。
> - 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。
> - 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。
> - 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。
> 节点 7 的边积分最高，所以返回 7 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> <img src="https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png" style="width: 150px; height: 155px;">
> <pre><strong>输入：</strong>edges = [2,0,0,2]
> <strong>输出：</strong>0
> <strong>解释：
> </strong>- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。
> - 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。
> 节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>n == edges.length</code></li>
> 	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= edges[i] &lt; n</code></li>
> 	<li><code>edges[i] != i</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d21;

class LC2374 {

  class Solution {

    public int edgeScore(int[] edges) {
      long[] inDegree = new long[100001];
      int max = 0;
      for (int i = 0; i < edges.length; i++) {
        int edge = edges[i];
        inDegree[edge] += i;
        if (inDegree[edge] > inDegree[max] || inDegree[edge] == inDegree[max] && edge < max) {
          max = edge;
        }
      }
      return max;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>找到小镇的法官

> <p>小镇里有 <code>n</code> 个人，按从 <code>1</code> 到 <code>n</code> 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。</p>
> 
> <p>如果小镇法官真的存在，那么：</p>
> 
> <ol>
> 	<li>小镇法官不会信任任何人。</li>
> 	<li>每个人（除了小镇法官）都信任这位小镇法官。</li>
> 	<li>只有一个人同时满足属性 <strong>1</strong> 和属性 <strong>2</strong> 。</li>
> </ol>
> 
> <p>给你一个数组 <code>trust</code> ，其中 <code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示编号为 <code>a<sub>i</sub></code> 的人信任编号为 <code>b<sub>i</sub></code> 的人。</p>
> 
> <p>如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 <code>-1</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 2, trust = [[1,2]]
> <strong>输出：</strong>2
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 3, trust = [[1,3],[2,3]]
> <strong>输出：</strong>3
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 3, trust = [[1,3],[2,3],[3,1]]
> <strong>输出：</strong>-1
> </pre>
> &nbsp;
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 1000</code></li>
> 	<li><code>0 &lt;= trust.length &lt;= 10<sup>4</sup></code></li>
> 	<li><code>trust[i].length == 2</code></li>
> 	<li><code>trust</code> 中的所有<code>trust[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> <strong>互不相同</strong></li>
> 	<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>
> 	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d22;

/*
 * https://leetcode.cn/problems/find-the-town-judge/submissions/566856174/
 * */
class LC997 {

  class Solution {

    public int findJudge(int n, int[][] trust) {
      int[] degree = new int[n + 1];
      int max = 1;
      for (int[] row : trust) {
        degree[row[0]] -= 1;
        degree[row[1]] += 1;
        if (degree[row[1]] > degree[max]) {
          max = row[1];
        }
      }
      if (degree[max] == n - 1) {
        return max;
      } else {
        return -1;
      }
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>最佳观光组合

> <p>给你一个正整数数组 <code>values</code>，其中 <code>values[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>j - i</code>。</p>
> 
> <p>一对景点（<code>i < j</code>）组成的观光组合的得分为 <code>values[i] + values[j] + i - j</code> ，也就是景点的评分之和<strong> 减去 </strong>它们两者之间的距离。</p>
> 
> <p>返回一对观光景点能取得的最高分。</p>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>values = [8,1,5,2,6]
> <strong>输出：</strong>11
> <strong>解释：</strong>i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>values = [1,2]
> <strong>输出：</strong>2
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 <= values.length <= 5 * 10<sup>4</sup></code></li>
> 	<li><code>1 <= values[i] <= 1000</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d23;

class LC1014 {

  class Solution {

    public int maxScoreSightseeingPair(int[] values) {
      int ans = Integer.MIN_VALUE;
      int max = values[0];
      for (int i = 1, valuesLength = values.length; i < valuesLength; i++) {
        int value = values[i];
        ans = Math.max(ans, max + value - i);
        max = Math.max(max, i + value);
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>字符串中最多数目的子序列

> <p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串&nbsp;<code>text</code>&nbsp;和另一个下标从 <strong>0</strong>&nbsp;开始且长度为 <code>2</code>&nbsp;的字符串&nbsp;<code>pattern</code>&nbsp;，两者都只包含小写英文字母。</p>
> 
> <p>你可以在 <code>text</code>&nbsp;中任意位置插入 <strong>一个</strong> 字符，这个插入的字符必须是&nbsp;<code>pattern[0]</code>&nbsp;<b>或者</b>&nbsp;<code>pattern[1]</code>&nbsp;。注意，这个字符可以插入在 <code>text</code>&nbsp;开头或者结尾的位置。</p>
> 
> <p>请你返回插入一个字符后，<code>text</code>&nbsp;中最多包含多少个等于 <code>pattern</code>&nbsp;的 <strong>子序列</strong>&nbsp;。</p>
> 
> <p><strong>子序列</strong> 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>text = "abdcdbc", pattern = "ac"
> <b>输出：</b>4
> <strong>解释：</strong>
> 如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 "ab<em><strong>a</strong></em>dcdbc" 。那么 "ac" 作为子序列出现 4 次。
> 其他得到 4 个 "ac" 子序列的方案还有 "<em><strong>a</strong></em>abdcdbc" 和 "abd<em><strong>a</strong></em>cdbc" 。
> 但是，"abdc<em><strong>a</strong></em>dbc" ，"abd<em><strong>c</strong></em>cdbc" 和 "abdcdbc<em><strong>c</strong></em>" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 "ac" 子序列，所以不是最优解。
> 可以证明插入一个字符后，无法得到超过 4 个 "ac" 子序列。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>text = "aabb", pattern = "ab"
> <b>输出：</b>6
> <strong>解释：</strong>
> 可以得到 6 个 "ab" 子序列的部分方案为 "<em><strong>a</strong></em>aabb" ，"aa<em><strong>a</strong></em>bb" 和 "aab<em><strong>b</strong></em>b" 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= text.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>pattern.length == 2</code></li>
> 	<li><code>text</code> 和&nbsp;<code>pattern</code>&nbsp;都只包含小写英文字母。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d24;

/*
 * https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/description/
 * */
class LC2207 {

  class Solution {

    public long maximumSubsequenceCount(String text, String pattern) {
      char a = pattern.charAt(0);
      char b = pattern.charAt(1);
      long cnt = 0;
      int aCnt = 0;
      int bCnt = 0;
      for (char c : text.toCharArray()) {
        if (c == b) {
          bCnt++;
          cnt += aCnt;
        }
        if (c == a) {
          aCnt++;
        }
      }
      return cnt + Math.max(aCnt, bCnt);
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>公司命名

> <p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p>
> 
> <ol>
> 	<li>从 <code>ideas</code> 中选择 2 个 <strong>不同</strong> 名字，称为 <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> 。</li>
> 	<li>交换 <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> 的首字母。</li>
> 	<li>如果得到的两个新名字 <strong>都</strong> 不在 <code>ideas</code> 中，那么 <code>idea<sub>A</sub> idea<sub>B</sub></code>（<strong>串联</strong> <code>idea<sub>A</sub></code> 和 <code>idea<sub>B</sub></code> ，中间用一个空格分隔）是一个有效的公司名字。</li>
> 	<li>否则，不是一个有效的名字。</li>
> </ol>
> 
> <p>返回 <strong>不同</strong> 且有效的公司名字的数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><strong>输入：</strong>ideas = ["coffee","donuts","time","toffee"]
> <strong>输出：</strong>6
> <strong>解释：</strong>下面列出一些有效的选择方案：
> - ("coffee", "donuts")：对应的公司名字是 "doffee conuts" 。
> - ("donuts", "coffee")：对应的公司名字是 "conuts doffee" 。
> - ("donuts", "time")：对应的公司名字是 "tonuts dime" 。
> - ("donuts", "toffee")：对应的公司名字是 "tonuts doffee" 。
> - ("time", "donuts")：对应的公司名字是 "dime tonuts" 。
> - ("toffee", "donuts")：对应的公司名字是 "doffee tonuts" 。
> 因此，总共有 6 个不同的公司名字。
> 
> 下面列出一些无效的选择方案：
> - ("coffee", "time")：在原数组中存在交换后形成的名字 "toffee" 。
> - ("time", "toffee")：在原数组中存在交换后形成的两个名字。
> - ("coffee", "toffee")：在原数组中存在交换后形成的两个名字。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><strong>输入：</strong>ideas = ["lack","back"]
> <strong>输出：</strong>0
> <strong>解释：</strong>不存在有效的选择方案。因此，返回 0 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= ideas.length &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>1 &lt;= ideas[i].length &lt;= 10</code></li>
> 	<li><code>ideas[i]</code> 由小写英文字母组成</li>
> 	<li><code>ideas</code> 中的所有字符串 <strong>互不相同</strong></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d25;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/*
 * https://leetcode.cn/problems/naming-a-company/
 * */
class LC2306 {

  public long distinctNames(String[] ideas) {
    long ans = 0;
    Set<String>[] groups = new Set[26];
    Arrays.setAll(groups, i -> new HashSet<>());
    for (String idea : ideas) {
      char first = idea.charAt(0);
      groups[first - 'a'].add(idea.substring(1));
    }
    for (int a = 0; a < 25; a++) {
      for (int b = a + 1; b < 26; b++) {
        int size = 0;
        for (String s : groups[a]) {
          if (groups[b].contains(s)) {
            size++;
          }
        }
        ans += (long) (groups[a].size() - size) * (groups[b].size() - size);
      }
    }
    return ans * 2;
  }

}
```
</li>
</ul>
</li>
<li>
<ul>
<li>数组元素和与数字和的绝对差

> <p>给你一个正整数数组 <code>nums</code> 。</p>
> 
> <ul>
> 	<li><strong>元素和</strong> 是 <code>nums</code> 中的所有元素相加求和。</li>
> 	<li><strong>数字和</strong> 是&nbsp;<code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。</li>
> </ul>
> 
> <p>返回 <strong>元素和</strong> 与 <strong>数字和</strong> 的绝对差。</p>
> 
> <p><strong>注意：</strong>两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1,15,6,3]
> <strong>输出：</strong>9
> <strong>解释：</strong>
> nums 的元素和是 1 + 15 + 6 + 3 = 25 。
> nums 的数字和是 1 + 1 + 5 + 6 + 3 = 16 。
> 元素和与数字和的绝对差是 |25 - 16| = 9 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1,2,3,4]
> <strong>输出：</strong>0
> <strong>解释：</strong>
> nums 的元素和是 1 + 2 + 3 + 4 = 10 。
> nums 的数字和是 1 + 2 + 3 + 4 = 10 。
> 元素和与数字和的绝对差是 |10 - 10| = 0 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d26;

/*
 * https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array/description/
 * */
class LC2535 {

  class Solution {

    public int differenceOfSum(int[] nums) {
      int sum1 = 0;
      int sum2 = 0;
      for (int num : nums) {
        sum1 += num;
        while (num > 0) {
          sum2 += num % 10;
          num /= 10;
        }
      }
      return Math.abs(sum1 - sum2);
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>每种字符至少取 K 个

> <p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>
> 
> <p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回<em> </em><code>-1</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "aabaaaacaabc", k = 2
> <strong>输出：</strong>8
> <strong>解释：</strong>
> 从 s 的左侧取三个字符，现在共取到两个字符 'a' 、一个字符 'b' 。
> 从 s 的右侧取五个字符，现在共取到四个字符 'a' 、两个字符 'b' 和两个字符 'c' 。
> 共需要 3 + 5 = 8 分钟。
> 可以证明需要的最少分钟数是 8 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "a", k = 1
> <strong>输出：</strong>-1
> <strong>解释：</strong>无法取到一个字符 'b' 或者 'c'，所以返回 -1 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>s</code> 仅由字母 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成</li>
> 	<li><code>0 &lt;= k &lt;= s.length</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d27;

/*
 * https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description/
 * */
class LC2516 {

  // 正难则反, 正向考虑取字符是在字符串的两端, 不连续状态很多, 反过来想最终结果不取的字符串是连续的
  // 也就是在字符串s中取得一串最大长度的连续子串使得左右两端的子串中包含abc的次数都大于k
  class Solution {

    public int takeCharacters(String s, int k) {
      char[] arr = s.toCharArray();
      int n = arr.length;
      //长度不够取足够字母
      if (n < k * 3) {
        return -1;
      }
      // 先将所有字母都取
      int[] cnt = new int[3];
      for (char c : arr) {
        cnt[c - 'a']++;
      }
      //有字母没取满k
      if (cnt[0] < k || cnt[1] < k || cnt[2] < k) {
        return -1;
      }
      //中间的不选的连续子串最大长度
      int max = 0;
      int l = 0;
      //滑动窗口, 不断扩展窗口右边界, 将arr[r]由取转换为不取, 当有字母取的数量小于k时, 缩短左边界, 维护滑窗的最大有效长度
      for (int r = 0; r < n; r++) {
        int i = arr[r] - 'a';
        cnt[i]--;
        while (cnt[i] < k) {
          cnt[arr[l] - 'a']++;
          l++;
        }
        max = Math.max(max, r - l + 1);
      }
      return n - max;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>以组为单位订音乐会的门票

> <p>一个音乐会总共有&nbsp;<code>n</code>&nbsp;排座位，编号从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;，每一排有&nbsp;<code>m</code>&nbsp;个座椅，编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>m - 1</code>&nbsp;。你需要设计一个买票系统，针对以下情况进行座位安排：</p>
> 
> <ul>
> 	<li>同一组的 <code>k</code>&nbsp;位观众坐在<strong> 同一排座位，且座位连续 </strong>。</li>
> 	<li><code>k</code>&nbsp;位观众中 <strong>每一位</strong>&nbsp;都有座位坐，但他们 <strong>不一定</strong>&nbsp;坐在一起。</li>
> </ul>
> 
> <p>由于观众非常挑剔，所以：</p>
> 
> <ul>
> 	<li>只有当一个组里所有成员座位的排数都 <strong>小于等于</strong>&nbsp;<code>maxRow</code>&nbsp;，这个组才能订座位。每一组的&nbsp;<code>maxRow</code>&nbsp;可能 <strong>不同</strong>&nbsp;。</li>
> 	<li>如果有多排座位可以选择，优先选择 <strong>最小</strong>&nbsp;的排数。如果同一排中有多个座位可以坐，优先选择号码 <strong>最小</strong>&nbsp;的。</li>
> </ul>
> 
> <p>请你实现&nbsp;<code>BookMyShow</code>&nbsp;类：</p>
> 
> <ul>
> 	<li><code>BookMyShow(int n, int m)</code>&nbsp;，初始化对象，<code>n</code>&nbsp;是排数，<code>m</code>&nbsp;是每一排的座位数。</li>
> 	<li><code>int[] gather(int k, int maxRow)</code>&nbsp;返回长度为 <code>2</code>&nbsp;的数组，表示 <code>k</code>&nbsp;个成员中 <strong>第一个座位</strong>&nbsp;的排数和座位编号，这 <code>k</code>&nbsp;位成员必须坐在 <strong>同一排座位，且座位连续 </strong>。换言之，返回最小可能的&nbsp;<code>r</code> 和&nbsp;<code>c</code>&nbsp;满足第&nbsp;<code>r</code>&nbsp;排中&nbsp;<code>[c, c + k - 1]</code>&nbsp;的座位都是空的，且&nbsp;<code>r &lt;= maxRow</code>&nbsp;。如果&nbsp;<strong>无法</strong>&nbsp;安排座位，返回&nbsp;<code>[]</code>&nbsp;。</li>
> 	<li><code>boolean scatter(int k, int maxRow)</code>&nbsp;如果组里所有&nbsp;<code>k</code>&nbsp;个成员&nbsp;<strong>不一定</strong>&nbsp;要坐在一起的前提下，都能在第&nbsp;<code>0</code> 排到第&nbsp;<code>maxRow</code>&nbsp;排之间找到座位，那么请返回&nbsp;<code>true</code>&nbsp;。这种情况下，每个成员都优先找排数&nbsp;<strong>最小</strong>&nbsp;，然后是座位编号最小的座位。如果不能安排所有&nbsp;<code>k</code>&nbsp;个成员的座位，请返回&nbsp;<code>false</code>&nbsp;。</li>
> </ul>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>
> ["BookMyShow", "gather", "gather", "scatter", "scatter"]
> [[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]
> <strong>输出：</strong>
> [null, [0, 0], [], true, false]
> 
> <strong>解释：</strong>
> BookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。
> bms.gather(4, 0); // 返回 [0, 0]
>                   // 这一组安排第 0 排 [0, 3] 的座位。
> bms.gather(2, 0); // 返回 []
>                   // 第 0 排只剩下 1 个座位。
>                   // 所以无法安排 2 个连续座位。
> bms.scatter(5, 1); // 返回 True
>                    // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。
> bms.scatter(5, 1); // 返回 False
>                    // 总共只剩下 2 个座位。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>1 &lt;= m, k &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>
> 	<li><code>gather</code> 和&nbsp;<code>scatter</code>&nbsp;<strong>总</strong> 调用次数不超过&nbsp;<code>5 * 10<sup>4</sup></code> 次。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d28;

/**
 * https://leetcode.cn/problems/booking-concert-tickets-in-groups/description/?envType=daily-question&envId=2024-09-28
 */
class LC2286 {

  class BookMyShow {

    private int n;
    private int m;
    private int[] min;
    private long[] sum;

    public BookMyShow(int n, int m) {
      this.n = n;
      this.m = m;
      int size = 2 << (32 - Integer.numberOfLeadingZeros(n)); // 比 4n 更小
      min = new int[size];
      sum = new long[size];
    }

    public int[] gather(int k, int maxRow) {
      // 找第一个能倒入 k 升水的水桶
      int r = findFirst(1, 0, n - 1, maxRow, m - k);
      if (r < 0) { // 没有这样的水桶
        return new int[]{};
      }
      int c = (int) querySum(1, 0, n - 1, r, r);
      update(1, 0, n - 1, r, k); // 倒水
      return new int[]{r, c};
    }

    public boolean scatter(int k, int maxRow) {
      // [0,maxRow] 的接水量之和
      long s = querySum(1, 0, n - 1, 0, maxRow);
      if (s > (long) m * (maxRow + 1) - k) {
        return false; // 水桶已经装了太多的水
      }
      // 从第一个没有装满的水桶开始
      int i = findFirst(1, 0, n - 1, maxRow, m - 1);
      while (k > 0) {
        int left = Math.min(m - (int) querySum(1, 0, n - 1, i, i), k);
        update(1, 0, n - 1, i, left); // 倒水
        k -= left;
        i++;
      }
      return true;
    }

    // 把下标 i 上的元素值增加 val
    private void update(int o, int l, int r, int i, int val) {
      if (l == r) {
        min[o] += val;
        sum[o] += val;
        return;
      }
      int m = (l + r) / 2;
      if (i <= m) {
        update(o * 2, l, m, i, val);
      } else {
        update(o * 2 + 1, m + 1, r, i, val);
      }
      min[o] = Math.min(min[o * 2], min[o * 2 + 1]);
      sum[o] = sum[o * 2] + sum[o * 2 + 1];
    }

    // 返回区间 [L,R] 内的元素和
    private long querySum(int o, int l, int r, int L, int R) {
      if (L <= l && r <= R) {
        return sum[o];
      }
      long res = 0;
      int m = (l + r) / 2;
      if (L <= m) {
        res = querySum(o * 2, l, m, L, R);
      }
      if (R > m) {
        res += querySum(o * 2 + 1, m + 1, r, L, R);
      }
      return res;
    }

    // 返回区间 [0,R] 中 <= val 的最靠左的位置，不存在时返回 -1
    private int findFirst(int o, int l, int r, int R, int val) {
      if (min[o] > val) {
        return -1; // 整个区间的元素值都大于 val
      }
      if (l == r) {
        return l;
      }
      int m = (l + r) / 2;
      if (min[o * 2] <= val) {
        return findFirst(o * 2, l, m, R, val);
      }
      if (R > m) {
        return findFirst(o * 2 + 1, m + 1, r, R, val);
      }
      return -1;
    }
  }
/**
 * Your BookMyShow object will be instantiated and called as such:
 * BookMyShow obj = new BookMyShow(n, m);
 * int[] param_1 = obj.gather(k,maxRow);
 * boolean param_2 = obj.scatter(k,maxRow);
 */
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>买票需要的时间

> <p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 <strong>最前方</strong> ，第 <code>(n - 1)</code> 人站在队伍 <strong>最后方</strong> 。</p>
> 
> <p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p>
> 
> <p>每个人买票都需要用掉 <strong>恰好 1 秒</strong> 。一个人 <strong>一次只能买一张票</strong> ，如果需要购买更多票，他必须走到&nbsp; <strong>队尾</strong> 重新排队（<strong>瞬间 </strong>发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 <strong>离开</strong> 队伍。</p>
> 
> <p>返回位于位置 <code>k</code>（下标从 <strong>0</strong> 开始）的人完成买票需要的时间（以秒为单位）。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><strong>输入：</strong>tickets = [2,3,2], k = 2
> <strong>输出：</strong>6
> <strong>解释：</strong> 
> - 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。
> - 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。
> 位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><strong>输入：</strong>tickets = [5,1,1,1], k = 0
> <strong>输出：</strong>8
> <strong>解释：</strong>
> - 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。
> - 接下来的 4 轮，只有位置 0 的人在买票。
> 位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>n == tickets.length</code></li>
> 	<li><code>1 &lt;= n &lt;= 100</code></li>
> 	<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>
> 	<li><code>0 &lt;= k &lt; n</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d29;

/*
 *
 * https://leetcode.cn/problems/time-needed-to-buy-tickets/description/?envType=daily-question&envId=2024-09-29
 * */
class LC2073 {

  class Solution {

    public int timeRequiredToBuy(int[] tickets, int k) {
      int ans = 0;
      int max = tickets[k];
      for (int i = 0; i < tickets.length; i++) {
        if (i <= k) {
          ans += Math.min(max, tickets[i]);
        } else {
          ans += Math.min(max - 1, tickets[i]);
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>座位预约管理系统

> <p>请你设计一个管理 <code>n</code> 个座位预约的系统，座位编号从 <code>1</code> 到 <code>n</code> 。</p>
> 
> <p>请你实现 <code>SeatManager</code> 类：</p>
> 
> <ul>
> 	<li><code>SeatManager(int n)</code> 初始化一个 <code>SeatManager</code> 对象，它管理从 <code>1</code> 到 <code>n</code> 编号的 <code>n</code> 个座位。所有座位初始都是可预约的。</li>
> 	<li><code>int reserve()</code> 返回可以预约座位的 <strong>最小编号</strong> ，此座位变为不可预约。</li>
> 	<li><code>void unreserve(int seatNumber)</code> 将给定编号 <code>seatNumber</code> 对应的座位变成可以预约。</li>
> </ul>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><strong>输入：</strong>
> ["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
> [[5], [], [], [2], [], [], [], [], [5]]
> <strong>输出：</strong>
> [null, 1, 2, null, 2, 3, 4, 5, null]
> 
> <strong>解释：</strong>
> SeatManager seatManager = new SeatManager(5); // 初始化 SeatManager ，有 5 个座位。
> seatManager.reserve();    // 所有座位都可以预约，所以返回最小编号的座位，也就是 1 。
> seatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。
> seatManager.unreserve(2); // 将座位 2 变为可以预约，现在可预约的座位为 [2,3,4,5] 。
> seatManager.reserve();    // 可以预约的座位为 [2,3,4,5] ，返回最小编号的座位，也就是 2 。
> seatManager.reserve();    // 可以预约的座位为 [3,4,5] ，返回最小编号的座位，也就是 3 。
> seatManager.reserve();    // 可以预约的座位为 [4,5] ，返回最小编号的座位，也就是 4 。
> seatManager.reserve();    // 唯一可以预约的是座位 5 ，所以返回 5 。
> seatManager.unreserve(5); // 将座位 5 变为可以预约，现在可预约的座位为 [5] 。
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= seatNumber &lt;= n</code></li>
> 	<li>每一次对 <code>reserve</code> 的调用，题目保证至少存在一个可以预约的座位。</li>
> 	<li>每一次对 <code>unreserve</code> 的调用，题目保证 <code>seatNumber</code> 在调用函数前都是被预约状态。</li>
> 	<li>对 <code>reserve</code> 和 <code>unreserve</code> 的调用 <strong>总共</strong> 不超过 <code>10<sup>5</sup></code> 次。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m09.d30;

import java.util.PriorityQueue;

/*
 * https://leetcode.cn/problems/seat-reservation-manager/description/
 * */
class LC1845 {

  class SeatManager {

    //pq用来存放被unreserve退回的座位
    private PriorityQueue<Integer> pq = new PriorityQueue<>();
    //min表示在这个数之前的座位都是被预定过的
    private int min = 1;

    public SeatManager(int n) {
    }

    public int reserve() {
      //首先明确一点: unreserve方法退回的座位一定是比min小的, 所以优先返回队列中的座位
      if (!pq.isEmpty()) {
        return pq.poll();
      }
      return min++;
    }

    public void unreserve(int seatNumber) {
      //实际业务中这里应该写一个非法校验, 用于fast-fail
     /* if (seatNumber >= min) {
        return;
      }*/
      pq.offer(seatNumber);
    }
  }

/**
 * Your SeatManager object will be instantiated and called as such:
 * SeatManager obj = new SeatManager(n);
 * int param_1 = obj.reserve();
 * obj.unreserve(seatNumber);
 */
}
```
</li>
</ul>
</li>
</ol>
