<ol>
<li>
<ul>
<li>心算挑战

> 「力扣挑战赛」心算项目的挑战比赛中，要求选手从 `N` 张卡牌中选出 `cnt` 张卡牌，若这 `cnt` 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 `cnt` 张卡牌数字总和。
> 给定数组 `cards` 和 `cnt`，其中 `cards[i]` 表示第 `i` 张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。
> 
> **示例 1：**
> >输入：`cards = [1,2,8,9], cnt = 3`
> >
> >输出：`18`
> >
> >解释：选择数字为 1、8、9 的这三张卡牌，此时可获得最大的有效得分 1+8+9=18。
> 
> **示例 2：**
> >输入：`cards = [3,3,1], cnt = 1`
> >
> >输出：`0`
> >
> >解释：不存在获取有效得分的卡牌方案。
> 
> **提示：**
> - `1 <= cnt <= cards.length <= 10^5`
> - `1 <= cards[i] <= 1000`
> 
> 

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d01;

import com.hyperboat.util.generator.AKt;
import java.util.Arrays;

/*
 * https://leetcode.cn/problems/uOAnQW/description/
 * */
class LCP40 {

  public int maxmiumScore(int[] cards, int cnt) {
    Arrays.sort(cards);
    int n = cards.length;
    int minOdd = 0;
    int minEven = 0;
    int ans = 0;
    int index = n - 1;
    while (index >= 0) {
      if (cnt-- == 0) {
        break;
      }
      if ((cards[index] & 1) == 1) {
        minOdd = cards[index];
      } else {
        minEven = cards[index];
      }
      ans += cards[index];
      index--;
    }
    if ((ans & 1) == 0) {
      return ans;
    }

    int maxOdd = 0;
    int maxEven = 0;

    for (int i = index; i >= 0 && (maxEven == 0 || maxOdd == 0); i--) {
      if (minOdd != 0 && maxEven == 0 && ((cards[i] & 1) == 0)) {
        maxEven = ans + cards[i] - minOdd;
      }
      if (minEven != 0 && maxOdd == 0 && ((cards[i] & 1) == 1)) {
        maxOdd = ans + cards[i] - minEven;
      }
    }
    return Math.max(maxOdd, maxEven);
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3128

> <p>给你一个二维 boolean 矩阵&nbsp;<code>grid</code>&nbsp;。</p>
> 
> <p>如果&nbsp;<code>grid</code> 的 3 个元素的集合中，一个元素与另一个元素在 <strong>同一行</strong>，并且与第三个元素在 <strong>同一列</strong>，则该集合是一个 <strong>直角三角形</strong>。3 个元素 <strong>不必</strong> 彼此相邻。</p>
> 
> <p>请你返回使用 <code>grid</code>&nbsp;中的 3 个元素可以构建的 <strong>直角三角形</strong> 数目，且满足 3 个元素值 <strong>都</strong>&nbsp;为 1 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div style="display:flex; gap: 12px;">
> <table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
> 	<tbody>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 	</tbody>
> </table>
> 
> <table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
> 	<tbody>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 	</tbody>
> </table>
> </div>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [[0,1,0],[0,1,1],[0,1,0]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><b>解释：</b></p>
> 
> <p>有 2 个值为 1 的直角三角形。注意蓝色的那个 <strong>没有&nbsp;</strong>组成直角三角形，因为 3 个元素在同一列。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div style="display:flex; gap: 12px;">
> <table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
> 	<tbody>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 	</tbody>
> </table>
> </div>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>没有值为 1 的直角三角形。注意蓝色的那个&nbsp;<strong>没有</strong> 组成直角三角形。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div style="display:flex; gap: 12px;">
> <table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
> 	<tbody>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 	</tbody>
> </table>
> 
> <table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
> 	<tbody>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 		<tr>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid red; --darkreader-inline-border-top: #b30000; --darkreader-inline-border-right: #b30000; --darkreader-inline-border-bottom: #b30000; --darkreader-inline-border-left: #b30000;">1</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 			<td data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-border-right="" data-darkreader-inline-border-top="" style="padding: 5px 10px; border: 1px solid black; --darkreader-inline-border-top: #8c8273; --darkreader-inline-border-right: #8c8273; --darkreader-inline-border-bottom: #8c8273; --darkreader-inline-border-left: #8c8273;">0</td>
> 		</tr>
> 	</tbody>
> </table>
> </div>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [[1,0,1],[1,0,0],[1,0,0]]</span></p>
> 
> <p><strong>输出：</strong>2</p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>有两个值为 1 的直角三角形。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= grid.length &lt;= 1000</code></li>
> 	<li><code>1 &lt;= grid[i].length &lt;= 1000</code></li>
> 	<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d02;

/*
 * https://leetcode.cn/problems/right-triangles/
 * */
class LC3128 {

  public long numberOfRightTriangles(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[] countM = new int[m];
    int[] countN = new int[n];
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (grid[i][j] == 1) {
          countM[i]++;
          countN[j]++;
        }
      }
    }
    long ans = 0;
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (grid[i][j] == 1) {
          ans += (long) (countM[i] - 1) * (countN[j] - 1);
        }
      }
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3143

> <p>给你一个二维数组&nbsp;<code>points</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，其中&nbsp;<code>points[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个点的坐标，<code>s[i]</code>&nbsp;表示第 <code>i</code>&nbsp;个点的 <strong>标签</strong>&nbsp;。</p>
> 
> <p>如果一个正方形的中心在&nbsp;<code>(0, 0)</code>&nbsp;，所有边都平行于坐标轴，且正方形内&nbsp;<strong>不</strong>&nbsp;存在标签相同的两个点，那么我们称这个正方形是&nbsp;<strong>合法</strong>&nbsp;的。</p>
> 
> <p>请你返回 <strong>合法</strong>&nbsp;正方形中可以包含的 <strong>最多</strong>&nbsp;点数。</p>
> 
> <p><strong>注意：</strong></p>
> 
> <ul>
> 	<li>如果一个点位于正方形的边上或者在边以内，则认为该点位于正方形内。</li>
> 	<li>正方形的边长可以为零。</li>
> </ul>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/29/3708-tc1.png" style="width: 303px; height: 303px;" /></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = "abdca"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>边长为 4 的正方形包含两个点&nbsp;<code>points[0]</code> 和&nbsp;<code>points[1]</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/29/3708-tc2.png" style="width: 302px; height: 302px;" /></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>points = [[1,1],[-2,-2],[-2,2]], s = "abb"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>边长为 2 的正方形包含 1 个点&nbsp;<code>points[0]</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>points = [[1,1],[-1,-1],[2,-2]], s = "ccd"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>任何正方形都无法只包含&nbsp;<code>points[0]</code> 和&nbsp;<code>points[1]</code>&nbsp;中的一个点，所以合法正方形中都不包含任何点。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length, points.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>points[i].length == 2</code></li>
> 	<li><code>-10<sup>9</sup> &lt;= points[i][0], points[i][1] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>s.length == points.length</code></li>
> 	<li><code>points</code>&nbsp;中的点坐标互不相同。</li>
> 	<li><code>s</code>&nbsp;只包含小写英文字母。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d03;

import java.util.Arrays;

/*
 * https://leetcode.cn/problems/maximum-points-inside-the-square/description/
 * */
class LC3143 {

  public int maxPointsInsideSquare(int[][] points, String s) {
    int[] minArr = new int[26];
    Arrays.fill(minArr, Integer.MAX_VALUE);
    int min2 = Integer.MAX_VALUE;
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      int x = points[i][0];
      int y = points[i][0];
      int d = Math.max(Math.abs(x), Math.abs(y));
      if (d < minArr[c - 'a']) {
        min2 = Math.min(minArr[c - 'a'], min2);
        minArr[c - 'a'] = d;
      } else {
        min2 = Math.min(d, min2);
      }
    }
    int res = 0;
    for (int d : minArr) {
      if (d < min2) {
        res++;
      }
    }
    return res;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>另一棵树的子树

> <div class="original__bRMd">
> <div>
> <p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
> 
> <p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> <img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" style="width: 532px; height: 400px;" />
> <pre>
> <strong>输入：</strong>root = [3,4,5,1,2], subRoot = [4,1,2]
> <strong>输出：</strong>true
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> <img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg" style="width: 502px; height: 458px;" />
> <pre>
> <strong>输入：</strong>root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
> <strong>输出：</strong>false
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>
> 	<li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>
> 	<li><code>-10<sup>4</sup> <= root.val <= 10<sup>4</sup></code></li>
> 	<li><code>-10<sup>4</sup> <= subRoot.val <= 10<sup>4</sup></code></li>
> </ul>
> </div>
> </div>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d04;

/*
 * https://leetcode.cn/problems/subtree-of-another-tree/description/
 * */
class LC572 {

  public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    return check(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
  }

  public boolean check(TreeNode root, TreeNode subRoot) {
    if (subRoot == null) {
      return subRoot == root;
    }
    if (subRoot.val != root.val) {
      return false;
    }
    return check(root.left, subRoot.left) || check(root.right, subRoot.right);
  }

  class TreeNode {

    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
      this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
      this.val = val;
      this.left = left;
      this.right = right;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>不含连续1的非负整数

> <p>给定一个正整数 <code>n</code> ，请你统计在&nbsp;<code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1 </strong>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1:</strong></p>
> 
> <pre>
> <strong>输入:</strong> n = 5
> <strong>输出:</strong> 5
> <strong>解释:</strong> 
> 下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：
> 0 : 0
> 1 : 1
> 2 : 10
> 3 : 11
> 4 : 100
> 5 : 101
> 其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</pre>
> 
> <p><strong>示例 2:</strong></p>
> 
> <pre>
> <strong>输入:</strong> n = 1
> <strong>输出:</strong> 2
> </pre>
> 
> <p><strong>示例 3:</strong></p>
> 
> <pre>
> <strong>输入:</strong> n = 2
> <strong>输出:</strong> 3
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示:</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d05;

/*
 * https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/
 * */
class LC600 {

  static int[] dp = new int[32];

  static {
    dp[0] = dp[1] = 1;
    for (int i = 2; i < 32; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
  }

  public int findIntegers(int n) {
    int size = Integer.SIZE- Integer.numberOfLeadingZeros(n);
    int pre = 0;
    int res = 0;
    for (int i = size; i >= 0; i--) {
      int val = 1 << i;
      if ((n & val) != 0) {
        res += dp[i + 1];
        if (pre == 1) {
          break;
        }
        pre = 1;
      } else {
        pre = 0;
      }
      if (i == 0) {
        res++;
      }
    }
    return res;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3129

> <p>给你 3 个正整数&nbsp;<code>zero</code>&nbsp;，<code>one</code>&nbsp;和&nbsp;<code>limit</code>&nbsp;。</p>
> 
> <p>一个 <span data-keyword="binary-array">二进制数组</span> <code>arr</code> 如果满足以下条件，那么我们称它是 <strong>稳定的</strong> ：</p>
> 
> <ul>
> 	<li>0 在&nbsp;<code>arr</code>&nbsp;中出现次数 <strong>恰好</strong>&nbsp;为<strong>&nbsp;</strong><code>zero</code>&nbsp;。</li>
> 	<li>1 在&nbsp;<code>arr</code>&nbsp;中出现次数 <strong>恰好</strong>&nbsp;为&nbsp;<code>one</code>&nbsp;。</li>
> 	<li><code>arr</code> 中每个长度超过 <code>limit</code>&nbsp;的 <span data-keyword="subarray-nonempty">子数组</span> 都 <strong>同时</strong> 包含 0 和 1 。</li>
> </ul>
> 
> <p>请你返回 <strong>稳定</strong>&nbsp;二进制数组的 <em>总</em> 数目。</p>
> 
> <p>由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<b>取余</b>&nbsp;后返回。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>zero = 1, one = 1, limit = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>两个稳定的二进制数组为&nbsp;<code>[1,0]</code> 和&nbsp;<code>[0,1]</code>&nbsp;，两个数组都有一个 0 和一个 1 ，且没有子数组长度大于 2 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">zero = 1, one = 2, limit = 1</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>唯一稳定的二进制数组是&nbsp;<code>[1,0,1]</code>&nbsp;。</p>
> 
> <p>二进制数组&nbsp;<code>[1,1,0]</code> 和&nbsp;<code>[0,1,1]</code>&nbsp;都有长度为 2 且元素全都相同的子数组，所以它们不稳定。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>zero = 3, one = 3, limit = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>14</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>所有稳定的二进制数组包括&nbsp;<code>[0,0,1,0,1,1]</code>&nbsp;，<code>[0,0,1,1,0,1]</code>&nbsp;，<code>[0,1,0,0,1,1]</code>&nbsp;，<code>[0,1,0,1,0,1]</code>&nbsp;，<code>[0,1,0,1,1,0]</code>&nbsp;，<code>[0,1,1,0,0,1]</code>&nbsp;，<code>[0,1,1,0,1,0]</code>&nbsp;，<code>[1,0,0,1,0,1]</code>&nbsp;，<code>[1,0,0,1,1,0]</code>&nbsp;，<code>[1,0,1,0,0,1]</code>&nbsp;，<code>[1,0,1,0,1,0]</code>&nbsp;，<code>[1,0,1,1,0,0]</code>&nbsp;，<code>[1,1,0,0,1,0]</code>&nbsp;和&nbsp;<code>[1,1,0,1,0,0]</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= zero, one, limit &lt;= 200</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d06;

/*
 * https://leetcode.cn/problems/find-all-possible-stable-binary-arrays-i/
 * */
class LC3129 {

  public int numberOfStableArrays(int zero, int one, int limit) {
    int MOD = 1_000_000_007;
    int[][][] dp = new int[zero + 1][one + 1][2];
    for (int i = 1; i <= Math.min(zero, limit); i++) {
      dp[i][0][0] = 1;
    }
    for (int i = 1; i <= Math.min(one, limit); i++) {
      dp[0][i][1] = 1;
    }
    for (int i = 1; i <= zero; i++) {
      for (int j = 1; j <= one; j++) {
        dp[i][j][0] =
            (int) (((long) dp[i - 1][j][0] + dp[i - 1][j][1]
                + (i > limit ? MOD - dp[i - limit - 1][j][1] : 0)) % MOD);
        dp[i][j][1] =
            (int) (((long) dp[i][j - 1][0] + dp[i][j - 1][1]
                + (j > limit ? MOD - dp[i][j - limit - 1][0] : 0)) % MOD);
      }
    }
    return (dp[zero][one][0] + dp[zero][one][1]) % MOD;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3130

> <p>给你 3 个正整数&nbsp;<code>zero</code>&nbsp;，<code>one</code>&nbsp;和&nbsp;<code>limit</code>&nbsp;。</p>
> 
> <p>一个 <span data-keyword="binary-array">二进制数组</span> <code>arr</code> 如果满足以下条件，那么我们称它是 <strong>稳定的</strong> ：</p>
> 
> <ul>
> 	<li>0 在&nbsp;<code>arr</code>&nbsp;中出现次数 <strong>恰好</strong>&nbsp;为<strong>&nbsp;</strong><code>zero</code>&nbsp;。</li>
> 	<li>1 在&nbsp;<code>arr</code>&nbsp;中出现次数 <strong>恰好</strong>&nbsp;为&nbsp;<code>one</code>&nbsp;。</li>
> 	<li><code>arr</code> 中每个长度超过 <code>limit</code>&nbsp;的 <span data-keyword="subarray-nonempty">子数组</span> 都 <strong>同时</strong> 包含 0 和 1 。</li>
> </ul>
> 
> <p>请你返回 <strong>稳定</strong>&nbsp;二进制数组的 <em>总</em> 数目。</p>
> 
> <p>由于答案可能很大，将它对&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;<b>取余</b>&nbsp;后返回。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>zero = 1, one = 1, limit = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>两个稳定的二进制数组为&nbsp;<code>[1,0]</code> 和&nbsp;<code>[0,1]</code>&nbsp;，两个数组都有一个 0 和一个 1 ，且没有子数组长度大于 2 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">zero = 1, one = 2, limit = 1</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>唯一稳定的二进制数组是&nbsp;<code>[1,0,1]</code>&nbsp;。</p>
> 
> <p>二进制数组&nbsp;<code>[1,1,0]</code> 和&nbsp;<code>[0,1,1]</code>&nbsp;都有长度为 2 且元素全都相同的子数组，所以它们不稳定。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>zero = 3, one = 3, limit = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>14</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>所有稳定的二进制数组包括&nbsp;<code>[0,0,1,0,1,1]</code>&nbsp;，<code>[0,0,1,1,0,1]</code>&nbsp;，<code>[0,1,0,0,1,1]</code>&nbsp;，<code>[0,1,0,1,0,1]</code>&nbsp;，<code>[0,1,0,1,1,0]</code>&nbsp;，<code>[0,1,1,0,0,1]</code>&nbsp;，<code>[0,1,1,0,1,0]</code>&nbsp;，<code>[1,0,0,1,0,1]</code>&nbsp;，<code>[1,0,0,1,1,0]</code>&nbsp;，<code>[1,0,1,0,0,1]</code>&nbsp;，<code>[1,0,1,0,1,0]</code>&nbsp;，<code>[1,0,1,1,0,0]</code>&nbsp;，<code>[1,1,0,0,1,0]</code>&nbsp;和&nbsp;<code>[1,1,0,1,0,0]</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= zero, one, limit &lt;= 1000</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d07;

/*
 * https://leetcode.cn/problems/find-all-possible-stable-binary-arrays-ii/
 * */
class LC3130 {

  public int numberOfStableArrays(int zero, int one, int limit) {
    int MOD = 1_000_000_007;
    int[][][] dp = new int[zero + 1][one + 1][2];
    for (int i = 1; i <= Math.min(zero, limit); i++) {
      dp[i][0][0] = 1;
    }
    for (int i = 1; i <= Math.min(one, limit); i++) {
      dp[0][i][1] = 1;
    }
    for (int i = 1; i <= zero; i++) {
      for (int j = 1; j <= one; j++) {
        dp[i][j][0] =
            (int) (((long) dp[i - 1][j][0] + dp[i - 1][j][1]
                + (i > limit ? MOD - dp[i - limit - 1][j][1] : 0)) % MOD);
        dp[i][j][1] =
            (int) (((long) dp[i][j - 1][0] + dp[i][j - 1][1]
                + (j > limit ? MOD - dp[i][j - limit - 1][0] : 0)) % MOD);
      }
    }
    return (dp[zero][one][0] + dp[zero][one][1]) % MOD;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3131

> <p>给你两个长度相等的数组 <code>nums1</code> 和 <code>nums2</code>。</p>
> 
> <p>数组 <code>nums1</code> 中的每个元素都与变量 <code>x</code> 所表示的整数相加。如果 <code>x</code> 为负数，则表现为元素值的减少。</p>
> 
> <p>在与 <code>x</code> 相加后，<code>nums1</code> 和 <code>nums2</code> <strong>相等</strong> 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 <strong>相等</strong> 。</p>
> 
> <p>返回整数 <code>x</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1:</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">nums1 = [2,6,4], nums2 = [9,7,5]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">3</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>与 3 相加后，<code>nums1</code> 和 <code>nums2</code> 相等。</p>
> </div>
> 
> <p><strong class="example">示例 2:</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">nums1 = [10], nums2 = [5]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">-5</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>与 <code>-5</code> 相加后，<code>nums1</code> 和 <code>nums2</code> 相等。</p>
> </div>
> 
> <p><strong class="example">示例 3:</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">nums1 = [1,1,1,1], nums2 = [1,1,1,1]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>与 0 相加后，<code>nums1</code> 和 <code>nums2</code> 相等。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums1.length == nums2.length &lt;= 100</code></li>
> 	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
> 	<li>测试用例以这样的方式生成：存在一个整数 <code>x</code>，使得 <code>nums1</code> 中的每个元素都与 <code>x</code> 相加后，<code>nums1</code> 与 <code>nums2</code> 相等。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d08;

/*
 * https://leetcode.cn/problems/find-the-integer-added-to-array-i/
 * */
class LC3131 {

  public int addedInteger(int[] nums1, int[] nums2) {
    int n = nums1.length;
    for (int i = 1; i < n; i++) {
      if (nums1[0] < nums1[i]) {
        swap(nums1, 0, i);
      }
      if (nums2[0] < nums2[i]) {
        swap(nums2, 0, i);
      }
    }
    return nums2[0] - nums1[0];
  }

  public void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3132

> <p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>。</p>
> 
> <p>从 <code>nums1</code> 中移除两个元素，并且所有其他元素都与变量 <code>x</code> 所表示的整数相加。如果 <code>x</code> 为负数，则表现为元素值的减少。</p>
> 
> <p>执行上述操作后，<code>nums1</code> 和 <code>nums2</code> <strong>相等</strong> 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 <strong>相等</strong> 。</p>
> 
> <p>返回能够实现数组相等的 <strong>最小 </strong>整数<em> </em><code>x</code><em> </em>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1:</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">nums1 = [4,20,16,12,8], nums2 = [14,18,10]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">-2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>移除 <code>nums1</code> 中下标为 <code>[0,4]</code> 的两个元素，并且每个元素与 <code>-2</code> 相加后，<code>nums1</code> 变为 <code>[18,14,10]</code> ，与 <code>nums2</code> 相等。</p>
> </div>
> 
> <p><strong class="example">示例 2:</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">nums1 = [3,5,5,3], nums2 = [7,7]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>移除 <code>nums1</code> 中下标为 <code>[0,3]</code> 的两个元素，并且每个元素与 <code>2</code> 相加后，<code>nums1</code> 变为 <code>[7,7]</code> ，与 <code>nums2</code> 相等。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>3 &lt;= nums1.length &lt;= 200</code></li>
> 	<li><code>nums2.length == nums1.length - 2</code></li>
> 	<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
> 	<li>测试用例以这样的方式生成：存在一个整数 <code>x</code>，<code>nums1</code> 中的每个元素都与 <code>x</code> 相加后，再移除两个元素，<code>nums1</code> 可以与 <code>nums2</code> 相等。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d09;

import java.util.Arrays;
/**
* https://leetcode.cn/problems/find-the-integer-added-to-array-ii/description/
* */
class LC3132 {

  public int minimumAddedInteger(int[] nums1, int[] nums2) {
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    for (int i = 2; i > 0; i--) {
      int j = 0;
      int x = nums2[0] - nums1[i];
      for (int k = i; k < nums1.length; k++) {
        if (nums2[j] == nums1[k] + x && ++j == nums2.length) {
          return x;
        }
      }
    }
    return nums2[0] - nums1[0];
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>找到 Alice 和 Bob 可以相遇的建筑

> <p>给你一个下标从 <strong>0</strong>&nbsp;开始的正整数数组&nbsp;<code>heights</code>&nbsp;，其中&nbsp;<code>heights[i]</code>&nbsp;表示第 <code>i</code>&nbsp;栋建筑的高度。</p>
> 
> <p>如果一个人在建筑&nbsp;<code>i</code>&nbsp;，且存在&nbsp;<code>i &lt; j</code>&nbsp;的建筑&nbsp;<code>j</code>&nbsp;满足&nbsp;<code>heights[i] &lt; heights[j]</code>&nbsp;，那么这个人可以移动到建筑&nbsp;<code>j</code>&nbsp;。</p>
> 
> <p>给你另外一个数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;。第&nbsp;<code>i</code>&nbsp;个查询中，Alice 在建筑&nbsp;<code>a<sub>i</sub></code> ，Bob 在建筑&nbsp;<code>b<sub>i</sub></code><sub>&nbsp;</sub>。</p>
> 
> <p>请你能返回一个数组&nbsp;<code>ans</code>&nbsp;，其中&nbsp;<code>ans[i]</code>&nbsp;是第&nbsp;<code>i</code>&nbsp;个查询中，Alice 和 Bob 可以相遇的&nbsp;<strong>最左边的建筑</strong>&nbsp;。如果对于查询&nbsp;<code>i</code>&nbsp;，Alice<em> </em>和<em> </em>Bob 不能相遇，令&nbsp;<code>ans[i]</code> 为&nbsp;<code>-1</code>&nbsp;。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>heights = [6,4,8,5,2,7], queries = [[0,1],[0,3],[2,4],[3,4],[2,2]]
> <b>输出：</b>[2,5,-1,5,2]
> <b>解释：</b>第一个查询中，Alice 和 Bob 可以移动到建筑 2 ，因为 heights[0] &lt; heights[2] 且 heights[1] &lt; heights[2] 。
> 第二个查询中，Alice 和 Bob 可以移动到建筑 5 ，因为 heights[0] &lt; heights[5] 且 heights[3] &lt; heights[5] 。
> 第三个查询中，Alice 无法与 Bob 相遇，因为 Alice 不能移动到任何其他建筑。
> 第四个查询中，Alice 和 Bob 可以移动到建筑 5 ，因为 heights[3] &lt; heights[5] 且 heights[4] &lt; heights[5] 。
> 第五个查询中，Alice 和 Bob 已经在同一栋建筑中。
> 对于 ans[i] != -1 ，ans[i] 是 Alice 和 Bob 可以相遇的建筑中最左边建筑的下标。
> 对于 ans[i] == -1 ，不存在 Alice 和 Bob 可以相遇的建筑。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>heights = [5,3,8,2,6,1,4,6], queries = [[0,7],[3,5],[5,2],[3,0],[1,6]]
> <b>输出：</b>[7,6,-1,4,6]
> <strong>解释：</strong>第一个查询中，Alice 可以直接移动到 Bob 的建筑，因为 heights[0] &lt; heights[7] 。
> 第二个查询中，Alice 和 Bob 可以移动到建筑 6 ，因为 heights[3] &lt; heights[6] 且 heights[5] &lt; heights[6] 。
> 第三个查询中，Alice 无法与 Bob 相遇，因为 Bob 不能移动到任何其他建筑。
> 第四个查询中，Alice 和 Bob 可以移动到建筑 4 ，因为 heights[3] &lt; heights[4] 且 heights[0] &lt; heights[4] 。
> 第五个查询中，Alice 可以直接移动到 Bob 的建筑，因为 heights[1] &lt; heights[6] 。
> 对于 ans[i] != -1 ，ans[i] 是 Alice 和 Bob 可以相遇的建筑中最左边建筑的下标。
> 对于 ans[i] == -1 ，不存在 Alice 和 Bob 可以相遇的建筑。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= heights.length &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>1 &lt;= heights[i] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>1 &lt;= queries.length &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>queries[i] = [a<sub>i</sub>, b<sub>i</sub>]</code></li>
> 	<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= heights.length - 1</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d10;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/*
 * https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/
 * */
class LC2940 {

  public int[] leftmostBuildingQueries(int[] heights, int[][] queries) {
    int n = queries.length;
    int length = heights.length;
    int[] ans = new int[n];
    Arrays.fill(ans, -1);
    List<int[]>[] qs = new ArrayList[length];
    Arrays.setAll(qs, i -> new ArrayList<>());
    for (int i = 0; i < n; i++) {
      int[] query = queries[i];
      int a = query[0];
      int b = query[1];
      if (a > b) {
        a ^= b;
        b ^= a;
        a ^= b;
      }
      if (a == b || heights[a] < heights[b]) {
        ans[i] = b;
      } else {
        qs[b].add(new int[]{heights[a], i});
      }
    }
    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
    for (int i = 0; i < length; i++) {
      while (!pq.isEmpty() && pq.peek()[0] < heights[i]) {
        ans[pq.poll()[1]] = i;
      }
      for (int[] q : qs[i]) {
        pq.offer(q);
      }
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>不相交的线

> <p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
> 
> <p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code>&nbsp;和 <code>nums2[j]</code>&nbsp;的直线，这些直线需要同时满足：</p>
> 
> <ul>
> 	<li>&nbsp;<code>nums1[i] == nums2[j]</code></li>
> 	<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
> </ul>
> 
> <p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
> 
> <p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> <img alt="" src="https://assets.leetcode.com/uploads/2019/04/26/142.png" style="width: 400px; height: 286px;" />
> <pre>
> <strong>输入：</strong>nums1 = <span id="example-input-1-1">[1,4,2]</span>, nums2 = <span id="example-input-1-2">[1,2,4]</span>
> <strong>输出：</strong><span id="example-output-1">2</span>
> <strong>解释：</strong>可以画出两条不交叉的线，如上图所示。 
> 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
> </pre>
> 
> <div>
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums1 = <span id="example-input-2-1">[2,5,1,2,5]</span>, nums2 = <span id="example-input-2-2">[10,5,2,1,5,2]</span>
> <strong>输出：</strong><span id="example-output-2">3</span>
> </pre>
> 
> <div>
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums1 = <span id="example-input-3-1">[1,3,7,1,7,5]</span>, nums2 = <span id="example-input-3-2">[1,9,2,5,1]</span>
> <strong>输出：</strong><span id="example-output-3">2</span></pre>
> 
> <p>&nbsp;</p>
> </div>
> </div>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
> 	<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>
> </ul>
> 
> <p>&nbsp;</p>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d11;

class LC1035 {

  public int maxUncrossedLines(int[] nums1, int[] nums2) {
    int m = nums1.length;
    int n = nums2.length;
//    dp[i][j]表示nums1的前i个元素和nums2的前j个元素所能组成的最多的不相交的线的数量
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
        if (nums1[i] == nums1[j]) {
          dp[i + 1][j + 1] = Math.max(dp[i + 1][j + 1], dp[i][j] + 1);
        }
      }
    }
    return dp[m][n];
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>实现一个魔法字典

> <p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>
> 
> <p>实现 <code>MagicDictionary</code> 类：</p>
> 
> <ul>
> 	<li><code>MagicDictionary()</code> 初始化对象</li>
> 	<li><code>void buildDict(String[] dictionary)</code> 使用字符串数组 <code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li>
> 	<li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中<strong> 一个 </strong>字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
> </ul>
> 
> <p> </p>
> 
> <div class="top-view__1vxA">
> <div class="original__bRMd">
> <div>
> <p><strong>示例：</strong></p>
> 
> <pre>
> <strong>输入</strong>
> ["MagicDictionary", "buildDict", "search", "search", "search", "search"]
> [[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
> <strong>输出</strong>
> [null, null, false, true, false, false]
> 
> <strong>解释</strong>
> MagicDictionary magicDictionary = new MagicDictionary();
> magicDictionary.buildDict(["hello", "leetcode"]);
> magicDictionary.search("hello"); // 返回 False
> magicDictionary.search("hhllo"); // 将第二个 'h' 替换为 'e' 可以匹配 "hello" ，所以返回 True
> magicDictionary.search("hell"); // 返回 False
> magicDictionary.search("leetcoded"); // 返回 False
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 <= dictionary.length <= 100</code></li>
> 	<li><code>1 <= dictionary[i].length <= 100</code></li>
> 	<li><code>dictionary[i]</code> 仅由小写英文字母组成</li>
> 	<li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li>
> 	<li><code>1 <= searchWord.length <= 100</code></li>
> 	<li><code>searchWord</code> 仅由小写英文字母组成</li>
> 	<li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li>
> 	<li>最多调用 <code>100</code> 次 <code>search</code></li>
> </ul>
> </div>
> </div>
> </div>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d12;

/*
 * https://leetcode.cn/problems/implement-magic-dictionary/description/
 * */
class LC676 {

  Trie root;

  public LC676() {
    root = new Trie();
  }

  public void buildDict(String[] dictionary) {
    root.insert(dictionary);
  }

  public boolean search(String searchWord) {
    return dfs(searchWord, root, 0, 1);
  }

  public boolean dfs(String word, Trie node, int index, int limit) {
    if (index == word.length()) {
      return node.isLeaf && limit == 0;
    }
    int idx = word.charAt(index) - 'a';
    if (node.children[idx] != null && dfs(word, node.children[idx], index + 1, limit)) {
      return true;
    }
    if (limit > 0) {
      for (int i = 0; i < 26; i++) {
        Trie child = node.children[i];
        if (i != idx && child != null && dfs(word, child, index + 1, limit - 1)) {
          return true;
        }
      }
    }
    return false;
  }

  class Trie {

    boolean isLeaf;
    Trie[] children;

    public Trie() {
      children = new Trie[26];
    }

    public void insert(String[] words) {
      for (String word : words) {
        Trie root = this;
        for (char c : word.toCharArray()) {
          if (root.children[c - 'a'] == null) {
            root.children[c - 'a'] = new Trie();
          }
          root = root.children[c - 'a'];
        }
        root.isLeaf = true;
      }
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3151

> <p>如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 <strong>特殊数组</strong> 。</p>
> 
> <p>你有一个整数数组 <code>nums</code>。如果 <code>nums</code> 是一个 <strong>特殊数组</strong> ，返回 <code>true</code>，否则返回 <code>false</code>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [1]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">true</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>只有一个元素，所以答案为 <code>true</code>。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [2,1,4]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">true</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>只有两对相邻元素： <code>(2,1)</code> 和 <code>(1,4)</code>，它们都包含了奇偶性不同的数字，因此答案为 <code>true</code>。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [4,3,1,6]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">false</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums[1]</code> 和 <code>nums[2]</code> 都是奇数。因此答案为 <code>false</code>。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 100</code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d13;

/*
 * https://leetcode.cn/problems/special-array-i/
 * */
class LC3151 {

  static class Solution {

    public boolean isArraySpecial(int[] nums) {
      int n = nums.length;
      if (n < 2) {
        return true;
      }

      for (int i = 1; i < n; i++) {
        if ((nums[i] & 1) == (nums[i - 1] & 1)) {
          return false;
        }
      }

      return true;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3152

> <p>如果数组的每一对相邻元素都是两个奇偶性不同的数字，则该数组被认为是一个 <strong>特殊数组</strong> 。</p>
> 
> <p>你有一个整数数组 <code>nums</code> 和一个二维整数矩阵 <code>queries</code>，对于 <code>queries[i] = [from<sub>i</sub>, to<sub>i</sub>]</code>，请你帮助你检查 <span data-keyword="subarray">子数组</span> <code>nums[from<sub>i</sub>..to<sub>i</sub>]</code> 是不是一个 <strong>特殊数组 </strong>。</p>
> 
> <p>返回布尔数组 <code>answer</code>，如果 <code>nums[from<sub>i</sub>..to<sub>i</sub>]</code> 是特殊数组，则 <code>answer[i]</code> 为 <code>true</code> ，否则，<code>answer[i]</code> 为 <code>false</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [3,4,1,2,6], queries = [[0,4]]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">[false]</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>子数组是 <code>[3,4,1,2,6]</code>。2 和 6 都是偶数。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [4,3,1,6], queries = [[0,2],[2,3]]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">[false,true]</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <ol>
> 	<li>子数组是 <code>[4,3,1]</code>。3 和 1 都是奇数。因此这个查询的答案是 <code>false</code>。</li>
> 	<li>子数组是 <code>[1,6]</code>。只有一对：<code>(1,6)</code>，且包含了奇偶性不同的数字。因此这个查询的答案是 <code>true</code>。</li>
> </ol>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>queries[i].length == 2</code></li>
> 	<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;= nums.length - 1</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d14;

class LC3152 {

  public boolean[] isArraySpecial(int[] nums, int[][] queries) {
    int n = nums.length;
    int length = queries.length;
    int[] sum = new int[n];
    boolean[] ans = new boolean[length];
    for (int i = 1; i < n; i++) {
      sum[i] = sum[i] + nums[i] % 2 == nums[i - 1] % 2 ? 1 : 0;
    }
    for (int i = 0; i < queries.length; i++) {
      ans[i] = sum[queries[i][0]] == sum[queries[i][1]];
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3148

> <p>给你一个由 <strong>正整数</strong> 组成、大小为 <code>m x n</code> 的矩阵 <code>grid</code>。你可以从矩阵中的任一单元格移动到另一个位于正下方或正右侧的任意单元格（不必相邻）。从值为 <code>c1</code> 的单元格移动到值为 <code>c2</code> 的单元格的得分为 <code>c2 - c1</code> 。</p>
> 
> <p>你可以从<strong> 任一</strong> 单元格开始，并且必须至少移动一次。</p>
> 
> <p>返回你能得到的 <strong>最大 </strong>总得分。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> <img alt="" src="https://assets.leetcode.com/uploads/2024/03/14/grid1.png" style="width: 240px; height: 240px;" />
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">9</span></p>
> 
> <p><strong>解释：</strong>从单元格 <code>(0, 1)</code> 开始，并执行以下移动：<br />
> - 从单元格 <code>(0, 1)</code> 移动到 <code>(2, 1)</code>，得分为 <code>7 - 5 = 2</code> 。<br />
> - 从单元格 <code>(2, 1)</code> 移动到 <code>(2, 2)</code>，得分为 <code>14 - 7 = 7</code> 。<br />
> 总得分为 <code>2 + 7 = 9</code> 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/04/08/moregridsdrawio-1.png" style="width: 180px; height: 116px;" /></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">grid = [[4,3,2],[3,2,1]]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">-1</span></p>
> 
> <p><strong>解释：</strong>从单元格 <code>(0, 0)</code> 开始，执行一次移动：从 <code>(0, 0)</code> 到 <code>(0, 1)</code> 。得分为 <code>3 - 4 = -1</code> 。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>m == grid.length</code></li>
> 	<li><code>n == grid[i].length</code></li>
> 	<li><code>2 &lt;= m, n &lt;= 1000</code></li>
> 	<li><code>4 &lt;= m * n &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d15;

import java.util.Arrays;
import java.util.List;

class LC3148 {

  public int maxScore(List<List<Integer>> grid) {
    int m = grid.size();
    int n = grid.get(0).size();
    /*dp[i][j]表示当前[i][j]位置的最小值*/
    int[][] dp = new int[m + 1][n + 1];
    for (int[] i : dp) {
      Arrays.fill(i, Integer.MAX_VALUE / 2);
    }
    int ans = Integer.MIN_VALUE;
    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        int preMin = Math.min(dp[i][j + 1], dp[i + 1][j]);
        int x = grid.get(i).get(j);
        ans = Math.max(ans, x - preMin);
        dp[i + 1][j + 1] = Math.min(x, preMin);
      }
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3117

> <p>给你两个数组 <code>nums</code> 和 <code>andValues</code>，长度分别为 <code>n</code> 和 <code>m</code>。</p>
> 
> <p>数组的 <strong>值 </strong>等于该数组的 <strong>最后一个 </strong>元素。</p>
> 
> <p>你需要将 <code>nums</code> 划分为 <code>m</code> 个 <strong>不相交的连续 </strong><span data-keyword="subarray-nonempty">子数组</span>，对于第 <code>i<sup>th</sup></code> 个子数组 <code>[l<sub>i</sub>, r<sub>i</sub>]</code>，子数组元素的按位&nbsp;<code>AND</code>&nbsp;运算结果等于 <code>andValues[i]</code>，换句话说，对所有的 <code>1 &lt;= i &lt;= m</code>，<code>nums[l<sub>i</sub>] &amp; nums[l<sub>i</sub> + 1] &amp; ... &amp; nums[r<sub>i</sub>] == andValues[i]</code> ，其中 <code>&amp;</code> 表示按位&nbsp;<code>AND</code>&nbsp;运算符。</p>
> 
> <p>返回将 <code>nums</code> 划分为 <code>m</code> 个子数组所能得到的可能的 <strong>最小 </strong>子数组 <strong>值</strong> 之和。如果无法完成这样的划分，则返回 <code>-1</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">nums = [1,4,3,3,2], andValues = [0,3,3,2]</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">12</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>唯一可能的划分方法为：</p>
> 
> <ol>
> 	<li><code>[1,4]</code> 因为 <code>1 &amp; 4 == 0</code></li>
> 	<li><code>[3]</code> 因为单元素子数组的按位 <code>AND</code> 结果就是该元素本身</li>
> 	<li><code>[3]</code> 因为单元素子数组的按位 <code>AND</code> 结果就是该元素本身</li>
> 	<li><code>[2]</code> 因为单元素子数组的按位 <code>AND</code> 结果就是该元素本身</li>
> </ol>
> 
> <p>这些子数组的值之和为 <code>4 + 3 + 3 + 2 = 12</code></p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">nums = [2,3,5,7,7,7,5], andValues = [0,7,5]</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">17</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>划分 <code>nums</code> 的三种方式为：</p>
> 
> <ol>
> 	<li><code>[[2,3,5],[7,7,7],[5]]</code> 其中子数组的值之和为 <code>5 + 7 + 5 = 17</code></li>
> 	<li><code>[[2,3,5,7],[7,7],[5]]</code> 其中子数组的值之和为 <code>7 + 7 + 5 = 19</code></li>
> 	<li><code>[[2,3,5,7,7],[7],[5]]</code> 其中子数组的值之和为 <code>7 + 7 + 5 = 19</code></li>
> </ol>
> 
> <p>子数组值之和的最小可能值为 <code>17</code></p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong> <span class="example-io">nums = [1,2,3,4], andValues = [2]</span></p>
> 
> <p><strong>输出：</strong> <span class="example-io">-1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>整个数组 <code>nums</code> 的按位 <code>AND</code> 结果为 <code>0</code>。由于无法将 <code>nums</code> 划分为单个子数组使得元素的按位 <code>AND</code> 结果为 <code>2</code>，因此返回 <code>-1</code>。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n == nums.length &lt;= 10<sup>4</sup></code></li>
> 	<li><code>1 &lt;= m == andValues.length &lt;= min(n, 10)</code></li>
> 	<li><code>1 &lt;= nums[i] &lt; 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= andValues[j] &lt; 10<sup>5</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d16;

import java.util.HashMap;

class LC3117 {
  private int[] nums;
  private int[] andValues;
  private HashMap<Long, Integer> memo;
  private int m;
  private int n;

  public int minimumValueSum(int[] nums, int[] andValues) {
    m = nums.length;
    n = andValues.length;
    if (m < n) {
      return -1;
    }
    this.nums = nums;
    this.andValues = andValues;
    memo = new HashMap<>();
    int ans = dfs(0, 0, -1);
    return ans < Integer.MAX_VALUE / 2 ? ans : -1;
  }

  public int dfs(int i, int j, int and) {
    if (m - i < n - j) {
      return Integer.MAX_VALUE / 2;
    }
    if (j == n) {
      return i == m ? 0 : Integer.MAX_VALUE / 2;
    }
    and &= nums[i];
    long mask = (long) i << 36 | (long) j << 32 | and;
    //  String mask = "i" + i + "j" + j + "and" + and;
    if (memo.containsKey(mask)) {
      return memo.get(mask);
    }
    int res = dfs(i + 1, j, and);
    if (and == andValues[j]) {
      res = Math.min(res, dfs(i + 1, j + 1, -1) + nums[i]);
    }
    memo.put(mask, res);
    return res;
  }


}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3137

> <p>给你一个长度为 <code>n</code> 的字符串 <code>word</code> 和一个整数 <code>k</code> ，其中 <code>k</code> 是 <code>n</code> 的因数。</p>
> 
> <p>在一次操作中，你可以选择任意两个下标 <code>i</code> 和 <code>j</code>，其中 <code>0 &lt;= i, j &lt; n</code> ，且这两个下标都可以被 <code>k</code> 整除，然后用从 <code>j</code> 开始的长度为 <code>k</code> 的子串替换从 <code>i</code> 开始的长度为 <code>k</code> 的子串。也就是说，将子串 <code>word[i..i + k - 1]</code> 替换为子串 <code>word[j..j + k - 1]</code> 。</p>
> 
> <p>返回使 <code>word</code> 成为 <strong>K 周期字符串</strong> 所需的<strong> 最少</strong> 操作次数。</p>
> 
> <p>如果存在某个长度为 <code>k</code> 的字符串 <code>s</code>，使得 <code>word</code> 可以表示为任意次数连接 <code>s</code> ，则称字符串 <code>word</code> 是 <strong>K 周期字符串</strong> 。例如，如果 <code>word == "ababab"</code>，那么 <code>word</code> 就是 <code>s = "ab"</code> 时的 2 周期字符串 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block" style="
>     border-color: var(--border-tertiary);
>     border-left-width: 2px;
>     color: var(--text-secondary);
>     font-size: .875rem;
>     margin-bottom: 1rem;
>     margin-top: 1rem;
>     overflow: visible;
>     padding-left: 1rem;
> ">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">word = "leetcodeleet", k = 4</span></p>
> 
> <p><strong>输出：</strong><span class="example-io" style="
> font-family: Menlo,sans-serif;
> font-size: 0.85rem;
> ">1</span></p>
> 
> <p><strong>解释：</strong>可以选择 i = 4 和 j = 0 获得一个 4 周期字符串。这次操作后，word 变为 "leetleetleet" 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block" style="
>     border-color: var(--border-tertiary);
>     border-left-width: 2px;
>     color: var(--text-secondary);
>     font-size: .875rem;
>     margin-bottom: 1rem;
>     margin-top: 1rem;
>     overflow: visible;
>     padding-left: 1rem;
> ">
> <p><strong>输入：</strong><span class="example-io" style="
>     font-family: Menlo,sans-serif;
>     font-size: 0.85rem;
> ">word = "leetcoleet", k = 2</span></p>
> 
> <p><strong>输出：</strong>3</p>
> 
> <p><strong>解释：</strong>可以执行以下操作获得一个 2 周期字符串。</p>
> 
> <table border="1" bordercolor="#ccc" cellpadding="5" cellspacing="0" height="146" style="border-collapse:collapse; text-align: center; vertical-align: middle;">
> 	<tbody>
> 		<tr>
> 			<th>i</th>
> 			<th>j</th>
> 			<th>word</th>
> 		</tr>
> 		<tr>
> 			<td style="padding: 5px 15px;">0</td>
> 			<td style="padding: 5px 15px;">2</td>
> 			<td style="padding: 5px 15px;">etetcoleet</td>
> 		</tr>
> 		<tr>
> 			<td style="padding: 5px 15px;">4</td>
> 			<td style="padding: 5px 15px;">0</td>
> 			<td style="padding: 5px 15px;">etetetleet</td>
> 		</tr>
> 		<tr>
> 			<td style="padding: 5px 15px;">6</td>
> 			<td style="padding: 5px 15px;">0</td>
> 			<td style="padding: 5px 15px;">etetetetet</td>
> 		</tr>
> 	</tbody>
> </table>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n == word.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= k &lt;= word.length</code></li>
> 	<li><code>k</code> 能整除 <code>word.length</code> 。</li>
> 	<li><code>word</code> 仅由小写英文字母组成。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d17;

import java.util.HashMap;
import java.util.Map;

class LC3137 {

  class Solution {

    public int minimumOperationsToMakeKPeriodic(String word, int k) {
      Map<String, Integer> map = new HashMap<>();
      int n = word.length();
      int max = 0;
      for (int i = k; i < n; i += k) {
        String str = word.substring(i - k, i);
        int cnt = map.merge(str, 1, Integer::sum);
        max = Math.max(max, cnt);
      }
      return n / k - max;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>学生出勤记录 I

> <p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
> 
> <ul>
> 	<li><code>'A'</code>：Absent，缺勤</li>
> 	<li><code>'L'</code>：Late，迟到</li>
> 	<li><code>'P'</code>：Present，到场</li>
> </ul>
> 
> <p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
> 
> <ul>
> 	<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
> 	<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
> </ul>
> 
> <p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "PPALLP"
> <strong>输出：</strong>true
> <strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "PPALLL"
> <strong>输出：</strong>false
> <strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
> 	<li><code>s[i]</code> 为 <code>'A'</code>、<code>'L'</code> 或 <code>'P'</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d18;

class LC551 {

  static class Solution {

    public boolean checkRecord(String s) {
      int cntC = 0;
      int index = 0;
      int n = s.length();
      while (index < n) {
        char c = s.charAt(index);
        if (c == 'A') {
          if (++cntC == 2) {
            return false;
          }
          index++;
        } else if (c == 'L') {
          int cnt = 1;
          while (++index < n && s.charAt(index) == 'L') {
            if (++cnt >= 3) {
              return false;
            }
          }
        } else {
          index++;
        }
      }
      return true;
    }
  }

}
```
</li>
</ul>
</li>
<li>
<ul>
<li>学生出勤记录 II

> 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
> <ul>
> 	<li><code>'A'</code>：Absent，缺勤</li>
> 	<li><code>'L'</code>：Late，迟到</li>
> 	<li><code>'P'</code>：Present，到场</li>
> </ul>
> 
> <p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
> 
> <ul>
> 	<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>
> 	<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>
> </ul>
> 
> <p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 2
> <strong>输出：</strong>8
> <strong>解释：
> </strong>有 8 种长度为 2 的记录将被视为可奖励：
> "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL" 
> 只有"AA"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 1
> <strong>输出：</strong>3
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>n = 10101
> <strong>输出：</strong>183236316
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d19;

class LC552 {

  class Solution {

    public int checkRecord(int n) {
      return checkRecord2(n);
    }

    /*空间复杂度O(n)*/
    public int checkRecord2(int n) {
      /*dp[i][j][k]表示第i天共缺席j次连续迟到k次,因此j取值范围[0,2),k取值范围[0,3)*/
      /*第0天初始化为1*/
      int MOD = (int) 1e9 + 7;
      int[][][] dp = new int[n + 1][2][3];
      dp[0][0][0] = 1;
      for (int i = 1; i < n + 1; i++) {
        /*以P结尾*/
        for (int j = 0; j < 2; j++) {
          for (int k = 0; k < 3; k++) {
            dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % MOD;
          }
        }
        /*以A结尾*/
        for (int k = 0; k < 3; k++) {
          dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % MOD;
        }
        /*以L结尾*/
        for (int j = 0; j < 2; j++) {
          for (int k = 1; k < 3; k++) {
            dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;
          }
        }
      }
      int sum = 0;
      for (int j = 0; j < 2; j++) {
        for (int k = 0; k < 3; k++) {
          sum = (sum + dp[n][j][k]) % MOD;
        }
      }
      return sum;

    }

    /*空间复杂度O(1)*/
    public int checkRecord3(int n) {
      /*dp[i][j][k]表示第i天共缺席j次连续迟到k次,因此j取值范围[0,2),k取值范围[0,3)*/
      /*因为dp[i]只通过dp[i-1]转移, 所以可通过滚动数组将空间复杂度优化为O(1)*/
      /*第0天初始化为1*/
      int MOD = (int) 1e9 + 7;
      int[][] dp = new int[2][3];
      dp[0][0] = 1;
      for (int i = 1; i < n + 1; i++) {
        int[][] curr = new int[2][3];
        /*以P结尾*/
        for (int j = 0; j < 2; j++) {
          for (int k = 0; k < 3; k++) {
            curr[j][0] = (curr[j][0] + dp[j][k]) % MOD;
          }
        }
        /*以A结尾*/
        for (int k = 0; k < 3; k++) {
          curr[1][0] = (curr[1][0] + dp[0][k]) % MOD;
        }
        /*以L结尾*/
        for (int j = 0; j < 2; j++) {
          for (int k = 1; k < 3; k++) {
            curr[j][k] = (curr[j][k] + dp[j][k - 1]) % MOD;
          }
        }
        dp = curr;
      }
      int sum = 0;
      for (int j = 0; j < 2; j++) {
        for (int k = 0; k < 3; k++) {
          sum = (sum + dp[j][k]) % MOD;
        }
      }
      return sum;

    }
  }

}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3154

> <p>给你有一个 <strong>非负</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。有一个无限长度的台阶，<strong>最低</strong>&nbsp;一层编号为 0 。</p>
> 
> <p>Alice&nbsp;有一个整数&nbsp;<code>jump</code>&nbsp;，一开始值为 0 。Alice 从台阶 1 开始，可以使用 <strong>任意</strong>&nbsp;次操作，目标是到达第&nbsp;<code>k</code> 级台阶。假设 Alice 位于台阶 <code>i</code> ，一次 <strong>操作</strong> 中，Alice 可以：</p>
> 
> <ul>
> 	<li>向下走一级到&nbsp;<code>i - 1</code>&nbsp;，但该操作&nbsp;<strong>不能</strong>&nbsp;连续使用，如果在台阶第 0 级也不能使用。</li>
> 	<li>向上走到台阶&nbsp;<code>i + 2<sup>jump</sup></code>&nbsp;处，然后&nbsp;<code>jump</code>&nbsp;变为&nbsp;<code>jump + 1</code>&nbsp;。</li>
> </ul>
> 
> <p>请你返回 Alice 到达台阶 <code>k</code>&nbsp;处的总方案数。</p>
> 
> <p><b>注意</b>，Alice 可能到达台阶 <code>k</code>&nbsp;处后，通过一些操作重新回到台阶 <code>k</code>&nbsp;处，这视为不同的方案。</p>
> 
> <p>&nbsp;</p>
> 
> <p><b>示例 1：</b></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>k = 0</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>2 种到达台阶 0 的方案为：</p>
> 
> <ul>
> 	<li>Alice&nbsp;从台阶&nbsp;1 开始。
> 	<ul>
> 		<li>执行第一种操作，从台阶 1 向下走到台阶 0 。</li>
> 	</ul>
> 	</li>
> 	<li>Alice&nbsp;从台阶 1 开始。
> 	<ul>
> 		<li>执行第一种操作，从台阶 1 向下走到台阶 0 。</li>
> 		<li>执行第二种操作，向上走 2<sup>0</sup>&nbsp;级台阶到台阶 1 。</li>
> 		<li>执行第一种操作，从台阶 1 向下走到台阶 0 。</li>
> 	</ul>
> 	</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>k = 1</span></p>
> 
> <p><span class="example-io"><b>输出：</b>4</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>4 种到达台阶 1 的方案为：</p>
> 
> <ul>
> 	<li>Alice&nbsp;从台阶 1 开始，已经到达台阶 1 。</li>
> 	<li>Alice&nbsp;从台阶 1 开始。
> 	<ul>
> 		<li>执行第一种操作，从台阶 1 向下走到台阶 0 。</li>
> 		<li>执行第二种操作，向上走 2<sup>0</sup>&nbsp;级台阶到台阶 1 。</li>
> 	</ul>
> 	</li>
> 	<li>Alice&nbsp;从台阶 1 开始。
> 	<ul>
> 		<li>执行第二种操作，向上走 2<sup>0</sup>&nbsp;级台阶到台阶 2 。</li>
> 		<li>执行第一种操作，向下走 1 级台阶到台阶 1 。</li>
> 	</ul>
> 	</li>
> 	<li>Alice&nbsp;从台阶 1 开始。
> 	<ul>
> 		<li>执行第一种操作，从台阶 1 向下走到台阶 0 。</li>
> 		<li>执行第二种操作，向上走&nbsp;2<sup>0</sup>&nbsp;级台阶到台阶 1 。</li>
> 		<li>执行第一种操作，向下走 1 级台阶到台阶 0 。</li>
> 		<li>执行第二种操作，向上走 2<sup>1</sup>&nbsp;级台阶到台阶 2 。</li>
> 		<li>执行第一种操作，向下走&nbsp;1 级台阶到台阶 1 。</li>
> 	</ul>
> 	</li>
> </ul>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>0 &lt;= k &lt;= 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d20;

import java.util.HashMap;
import java.util.Map;

class LC3154 {

  static class Solution {

    Map<String, Integer> memo;
    public int waysToReachStair(int k) {
      memo = new HashMap<>();
      return dfs(false, 0, 1, k);

    }

    public int dfs(boolean back, int jump, int i, int k) {

      if (i > k + 1) {
        return 0;
      }
      String key = "jump" + jump + "i" + i + "back" + (back ? 0 : 1);
      if (memo.containsKey(key)) {
        return memo.get(key);
      }
      int res = k == i ? 1 : 0;
      if (!back && i > 0) {
        res += dfs(true, jump, i - 1, k);
      }
      res += dfs(false, jump + 1, i + (1 << jump), k);
      memo.put(key, res);
      return res;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>价值和小于等于 K 的最大数字

> <p>给你一个整数&nbsp;<code>k</code>&nbsp;和一个整数&nbsp;<code>x</code>&nbsp;。整数&nbsp;<code>num</code>&nbsp;的价值是由它的二进制表示中，从最低有效位开始，<code>x</code>，<code>2x</code>，<code>3x</code>，以此类推，这些位置上&nbsp;<strong>设置位</strong>&nbsp;的数目来计算。下面的表格包含了如何计算价值的例子。</p>
> 
> <table border="1">
> 	<tbody>
> 		<tr>
> 			<th>x</th>
> 			<th>num</th>
> 			<th>Binary Representation</th>
> 			<th>Price</th>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>13</td>
> 			<td><u>0</u><u>0</u><u>0</u><u>0</u><u>0</u><strong><u>1</u></strong><strong><u>1</u></strong><u>0</u><strong><u>1</u></strong></td>
> 			<td>3</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>13</td>
> 			<td>0<u>0</u>0<u>0</u>0<strong><u>1</u></strong>1<u>0</u>1</td>
> 			<td>1</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>233</td>
> 			<td>0<strong><u>1</u></strong>1<strong><u>1</u></strong>0<strong><u>1</u></strong>0<u>0</u>1</td>
> 			<td>3</td>
> 		</tr>
> 		<tr>
> 			<td>3</td>
> 			<td>13</td>
> 			<td><u>0</u>00<u>0</u>01<strong><u>1</u></strong>01</td>
> 			<td>1</td>
> 		</tr>
> 		<tr>
> 			<td>3</td>
> 			<td>362</td>
> 			<td><strong><u>1</u></strong>01<strong><u>1</u></strong>01<u>0</u>10</td>
> 			<td>2</td>
> 		</tr>
> 	</tbody>
> </table>
> 
> <p>&nbsp;</p>
> 
> <p><code>num</code>&nbsp;的 <strong>累加价值</strong> 是从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>num</code>&nbsp;的数字的 <strong>总</strong> 价值。如果&nbsp;<code>num</code>&nbsp;的累加价值小于或等于&nbsp;<code>k</code>&nbsp;则被认为是 <strong>廉价</strong> 的。</p>
> 
> <p>请你返回<strong>&nbsp;最大</strong>&nbsp;的廉价数字。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>k = 9, x = 1
> <b>输出：</b>6
> <b>解释：</b>由下表所示，6 是最大的廉价数字。
> </pre>
> 
> <table border="1">
> 	<tbody>
> 		<tr>
> 			<th>x</th>
> 			<th>num</th>
> 			<th>Binary Representation</th>
> 			<th>Price</th>
> 			<th>Accumulated Price</th>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>1</td>
> 			<td><u>0</u><u>0</u><strong><u>1</u></strong></td>
> 			<td>1</td>
> 			<td>1</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>2</td>
> 			<td><u>0</u><strong><u>1</u></strong><u>0</u></td>
> 			<td>1</td>
> 			<td>2</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>3</td>
> 			<td><u>0</u><strong><u>1</u></strong><strong><u>1</u></strong></td>
> 			<td>2</td>
> 			<td>4</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>4</td>
> 			<td><strong><u>1</u></strong><u>0</u><u>0</u></td>
> 			<td>1</td>
> 			<td>5</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>5</td>
> 			<td><strong><u>1</u></strong><u>0</u><strong><u>1</u></strong></td>
> 			<td>2</td>
> 			<td>7</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>6</td>
> 			<td><strong><u>1</u></strong><strong><u>1</u></strong><u>0</u></td>
> 			<td>2</td>
> 			<td>9</td>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>7</td>
> 			<td><strong><u>1</u></strong><strong><u>1</u></strong><strong><u>1</u></strong></td>
> 			<td>3</td>
> 			<td>12</td>
> 		</tr>
> 	</tbody>
> </table>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <pre>
> <b>输入：</b>k = 7, x = 2
> <b>输出：</b>9
> <b>解释：</b>由下表所示，9 是最大的廉价数字。
> </pre>
> 
> <table border="1">
> 	<tbody>
> 		<tr>
> 			<th>x</th>
> 			<th>num</th>
> 			<th>Binary Representation</th>
> 			<th>Price</th>
> 			<th>Accumulated Price</th>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>1</td>
> 			<td><u>0</u>0<u>0</u>1</td>
> 			<td>0</td>
> 			<td>0</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>2</td>
> 			<td><u>0</u>0<strong><u>1</u></strong>0</td>
> 			<td>1</td>
> 			<td>1</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>3</td>
> 			<td><u>0</u>0<strong><u>1</u></strong>1</td>
> 			<td>1</td>
> 			<td>2</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>4</td>
> 			<td><u>0</u>1<u>0</u>0</td>
> 			<td>0</td>
> 			<td>2</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>5</td>
> 			<td><u>0</u>1<u>0</u>1</td>
> 			<td>0</td>
> 			<td>2</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>6</td>
> 			<td><u>0</u>1<strong><u>1</u></strong>0</td>
> 			<td>1</td>
> 			<td>3</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>7</td>
> 			<td><u>0</u>1<strong><u>1</u></strong>1</td>
> 			<td>1</td>
> 			<td>4</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>8</td>
> 			<td><strong><u>1</u></strong>0<u>0</u>0</td>
> 			<td>1</td>
> 			<td>5</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>9</td>
> 			<td><strong><u>1</u></strong>0<u>0</u>1</td>
> 			<td>1</td>
> 			<td>6</td>
> 		</tr>
> 		<tr>
> 			<td>2</td>
> 			<td>10</td>
> 			<td><strong><u>1</u></strong>0<strong><u>1</u></strong>0</td>
> 			<td>2</td>
> 			<td>8</td>
> 		</tr>
> 	</tbody>
> </table>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= k &lt;= 10<sup>15</sup></code></li>
> 	<li><code>1 &lt;= x &lt;= 8</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d21;

class LC3007 {

  static class Solution {

    public long findMaximumNumber(long k, int x) {
      long l = 1, r = (k + 1) << x;
      while (l < r) {
        long m = (l + r + 1) / 2;
        if (accumulatedPrice(x, m) > k) {
          r = m - 1;
        } else {
          l = m;
        }
      }
      return l;
    }

    public long accumulatedPrice(int x, long num) {
      long res = 0;
      int length = 64 - Long.numberOfLeadingZeros(num);
      for (int i = x; i <= length; i += x) {
        res += accumulatedBitPrice(i, num);
      }
      return res;
    }

    public long accumulatedBitPrice(int x, long num) {
      long period = 1L << x;
      long res = period / 2 * (num / period);
      if (num % period >= period / 2) {
        res += num % period - (period / 2 - 1);
      }
      return res;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3133

> <p>给你两个整数 <code>n</code> 和 <code>x</code> 。你需要构造一个长度为 <code>n</code> 的 <strong>正整数 </strong>数组 <code>nums</code> ，对于所有 <code>0 &lt;= i &lt; n - 1</code> ，满足 <code>nums[i + 1]</code><strong> 大于 </strong><code>nums[i]</code> ，并且数组 <code>nums</code> 中所有元素的按位 <code>AND</code> 运算结果为 <code>x</code> 。</p>
> 
> <p>返回 <code>nums[n - 1]</code> 可能的<strong> 最小 </strong>值。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">n = 3, x = 4</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">6</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>数组 <code>nums</code> 可以是 <code>[4,5,6]</code> ，最后一个元素为 <code>6</code> 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">n = 2, x = 7</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">15</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>数组 <code>nums</code> 可以是 <code>[7,15]</code> ，最后一个元素为 <code>15</code> 。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n, x &lt;= 10<sup>8</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d22;

/*
 * https://leetcode.cn/problems/minimum-array-end/
 * */
class LC3133 {

  class Solution {

    public long minEnd(int n, int x) {
      n--;
      long ans = x;
      int j = 0;
      for (long t = ~x, lb; (n >> j) > 0; t ^= lb) {
        lb = t & -t;
        ans |= (long) (n >> j++ & 1) * lb;
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3145

> <p>一个非负整数 <code>x</code>&nbsp;的 <strong>强数组</strong>&nbsp;指的是满足元素为 2 的幂且元素总和为 <code>x</code> 的最短有序数组。下表说明了如何确定 <strong>强数组</strong> 的示例。可以证明，<code>x</code>&nbsp;对应的强数组是独一无二的。</p>
> 
> <table border="1">
> 	<tbody>
> 		<tr>
> 			<th>数字</th>
> 			<th>二进制表示</th>
> 			<th>强数组</th>
> 		</tr>
> 		<tr>
> 			<td>1</td>
> 			<td>0000<u>1</u></td>
> 			<td>[1]</td>
> 		</tr>
> 		<tr>
> 			<td>8</td>
> 			<td>0<u>1</u>000</td>
> 			<td>[8]</td>
> 		</tr>
> 		<tr>
> 			<td>10</td>
> 			<td>0<u>1</u>0<u>1</u>0</td>
> 			<td>[2, 8]</td>
> 		</tr>
> 		<tr>
> 			<td>13</td>
> 			<td>0<u>11</u>0<u>1</u></td>
> 			<td>[1, 4, 8]</td>
> 		</tr>
> 		<tr>
> 			<td>23</td>
> 			<td><u>1</u>0<u>111</u></td>
> 			<td>[1, 2, 4, 16]</td>
> 		</tr>
> 	</tbody>
> </table>
> 
> <p>&nbsp;</p>
> 
> <p>我们将每一个升序的正整数 <code>i</code>&nbsp;（即1，2，3等等）的 <strong>强数组</strong>&nbsp;连接得到数组&nbsp;<code>big_nums</code>&nbsp;，<code>big_nums</code>&nbsp;开始部分为&nbsp;<code>[<u>1</u>, <u>2</u>, <u>1, 2</u>, <u>4</u>, <u>1, 4</u>, <u>2, 4</u>, <u>1, 2, 4</u>, <u>8</u>, ...]</code>&nbsp;。</p>
> 
> <p>给你一个二维整数数组&nbsp;<code>queries</code>&nbsp;，其中&nbsp;<code>queries[i] = [from<sub>i</sub>, to<sub>i</sub>, mod<sub>i</sub>]</code>&nbsp;，你需要计算&nbsp;<code>(big_nums[from<sub>i</sub>] * big_nums[from<sub>i</sub> + 1] * ... * big_nums[to<sub>i</sub>]) % mod<sub>i</sub></code>&nbsp;。</p>
> 
> <p>请你返回一个整数数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;是第 <code>i</code>&nbsp;个查询的答案。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <p><b>输入：</b>queries = [[1,3,7]]</p>
> 
> <p><b>输出：</b>[4]</p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>只有一个查询。</p>
> 
> <p><code>big_nums[1..3] = [2,1,2]</code>&nbsp;。它们的乘积为 4。结果为&nbsp;<code>4 % 7 = 4</code>。</p>
> 
> <p><strong>示例 2：</strong></p>
> 
> <p><b>输入：</b>queries = [[2,5,3],[7,7,4]]</p>
> 
> <p><b>输出：</b>[2,2]</p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>有两个查询。</p>
> 
> <p>第一个查询：<code>big_nums[2..5] = [1,2,4,1]</code>&nbsp;。它们的乘积为 8 。结果为&nbsp; <code>8 % 3 = 2</code>。</p>
> 
> <p>第二个查询：<code>big_nums[7] = 2</code>&nbsp;。结果为 <code>2 % 4 = 2</code>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= queries.length &lt;= 500</code></li>
> 	<li><code>queries[i].length == 3</code></li>
> 	<li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt;= 10<sup>15</sup></code></li>
> 	<li><code>1 &lt;= queries[i][2] &lt;= 10<sup>5</sup></code></li>
> </ul>
> 
> <p>&nbsp;</p>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d23;

class LC3145 {

  class Solution {

    // 难度2859的题，做不出来 todo
    // 主要是想不到 幂次个数和数组下标的递推关系
    // 二分，快速幂都能想到
    public int[] findProductsOfElements(long[][] queries) {
      int[] ans = new int[queries.length];
      for (int i = 0; i < queries.length; i++) {
        long[] q = queries[i];
        long er = sumE(q[1] + 1);
        long el = sumE(q[0]);
        ans[i] = pow(2, er - el, q[2]);
      }
      return ans;
    }

    private long sumE(long k) {
      long res = 0;
      long n = 0;
      long cnt1 = 0; // 之前填的 1 的个数
      long sumI = 0; // 之前填的 1 的幂次之和
      for (long i = 63 - Long.numberOfLeadingZeros(k + 1); i >= 0; i--) {
        long c = (cnt1 << i) + (i << i >> 1); // 新增的幂次个数
        if (c <= k) {
          k -= c;
          res += (sumI << i) + ((i * (i - 1) / 2) << i >> 1);
          sumI += i;
          cnt1++;
          n |= 1L << i; // 填 1
        }
      }
      // 剩余的 k 个幂次，由 n 的低 k 个 1 补充
      while (k-- > 0) {
        res += Long.numberOfTrailingZeros(n);
        n &= n - 1; // 去掉最低位的 1（置为 0）
      }
      return res;
    }

    private int pow(long x, long n, long mod) {
      long res = 1 % mod; // 注意 mod 可能等于 1
      for (; n > 0; n /= 2) {
        if (n % 2 == 1) {
          res = res * x % mod;
        }
        x = x * x % mod;
      }
      return (int) res;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3146

> <p>给你两个字符串 <code>s</code> 和 <code>t</code>，每个字符串中的字符都不重复，且 <code>t</code> 是 <code>s</code> 的一个排列。</p>
> 
> <p><strong>排列差</strong> 定义为 <code>s</code> 和 <code>t</code> 中每个字符在两个字符串中位置的绝对差值之和。</p>
> 
> <p>返回 <code>s</code> 和 <code>t</code> 之间的<strong> 排列差 </strong>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">s = "abc", t = "bac"</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>对于 <code>s = "abc"</code> 和 <code>t = "bac"</code>，排列差是：</p>
> 
> <ul>
> 	<li><code>"a"</code> 在 <code>s</code> 中的位置与在 <code>t</code> 中的位置之差的绝对值。</li>
> 	<li><code>"b"</code> 在 <code>s</code> 中的位置与在 <code>t</code> 中的位置之差的绝对值。</li>
> 	<li><code>"c"</code> 在 <code>s</code> 中的位置与在 <code>t</code> 中的位置之差的绝对值。</li>
> </ul>
> 
> <p>即，<code>s</code> 和 <code>t</code> 的排列差等于 <code>|0 - 1| + |1 - 0| + |2&nbsp;- 2| = 2</code>。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">s = "abcde", t = "edbac"</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">12</span></p>
> 
> <p><strong>解释：</strong> <code>s</code> 和 <code>t</code> 的排列差等于 <code>|0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12</code>。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 26</code></li>
> 	<li>每个字符在 <code>s</code> 中最多出现一次。</li>
> 	<li><code>t</code> 是 <code>s</code> 的一个排列。</li>
> 	<li><code>s</code> 仅由小写英文字母组成。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d24;

class LC3146 {

  class Solution {

    public int findPermutationDifference(String s, String t) {
      int n = s.length();
      int ans = 0;
      int[] index = new int[26];
      for (int i = 0; i < n; i++) {
        char sc = s.charAt(i);
        index[sc - 'a'] = i;
      }
      for (int i = 0; i < n; i++) {
        int tc = t.charAt(i);
        ans += Math.abs(index[tc - 'a'] - i);
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>划分为k个相等的子集

> <p>给定一个整数数组&nbsp;&nbsp;<code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong> nums = [4, 3, 2, 3, 5, 2, 1], k = 4
> <strong>输出：</strong> True
> <strong>说明：</strong> 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</pre>
> 
> <p><strong>示例 2:</strong></p>
> 
> <pre>
> <strong>输入:</strong> nums = [1,2,3,4], k = 3
> <strong>输出:</strong> false</pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code></li>
> 	<li><code>0 &lt; nums[i] &lt; 10000</code></li>
> 	<li>每个元素的频率在 <code>[1,4]</code> 范围内</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d25;

import java.util.Arrays;

class LC698 {

  class Solution {


    private int k;
    private int sum;
    private int n;
    private int[] nums;

    public boolean canPartitionKSubsets(int[] nums, int k) {
      n = nums.length;
      sum = 0;
      this.nums = nums;
      this.k = k;
      for (int i = 0; i < n; i++) {
        sum += nums[i];
      }
      //总和不能被k整除, 返回false
      if (sum % k != 0) {
        return false;
      }
      //设置每组的和
      sum /= k;
      //排序, 从后往前遍历, 先挑最大的
      Arrays.sort(nums);
      return dfs(n - 1, 0, 0, new boolean[n]);
    }

    private boolean dfs(int index, int currSum, int cnt, boolean[] visited) {
      //分组选够k个了
      if (cnt == k) {
        return true;
      }
      //当前分组的和达到sum
      if (currSum == sum) {
        return dfs(n - 1, 0, cnt + 1, visited);
      }
      for (int i = index; i >= 0; i--) {
        //访问过, 当前和超出sum
        if (visited[i] || currSum + nums[i] > sum) {
          continue;
        }
        visited[i] = true;
        if (dfs(i - 1, currSum + nums[i], cnt, visited)) {
          return true;
        }
        visited[i] = false;
        //没有一个数选上,说明剩余待选的数都比sum大, 直接返回false即可
        if (currSum == 0) {
          return false;
        }
      }
      return false;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>员工的重要性

> <p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id </strong>，<strong>重要度 </strong>和 <strong>直系下属的 id </strong>。</p>
> 
> <p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p>
> 
> <p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>
> 
> <p> </p>
> 
> <p><strong>示例：</strong></p>
> 
> <pre>
> <strong>输入：</strong>[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
> <strong>输出：</strong>11
> <strong>解释：</strong>
> 员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li>一个员工最多有一个<strong> 直系 </strong>领导，但是可以有多个 <strong>直系 </strong>下属</li>
> 	<li>员工数量不超过 2000 。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d26;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

class LC690 {

  class Employee {

    public int id;
    public int importance;
    public List<Integer> subordinates;
  }


  class Solution {

    private Map<Integer, Employee> map;

    public int getImportance(List<Employee> employees, int id) {
      Employee leader = null;
      map = new HashMap<>();
      for (Employee employee : employees) {
        if (employee.id == id) {
          leader = employee;
        }
        map.put(employee.id, employee);
      }
      return dfs(leader);
    }

    public int dfs(Employee emp) {
      if (emp == null) {
        return 0;
      }
      int value = emp.importance;
      for (Integer subordinate : emp.subordinates) {
        value += dfs(map.get(subordinate));
      }
      return value;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3134

> <p>给你一个整数数组 <code>nums</code> 。数组 <code>nums</code> 的<strong> 唯一性数组</strong> 是一个按元素从小到大排序的数组，包含了 <code>nums</code> 的所有非空 <span data-keyword="subarray-nonempty">子数组</span> 中不同元素的个数。</p>
> 
> <p>换句话说，这是由所有 <code>0 &lt;= i &lt;= j &lt; nums.length</code> 的 <code>distinct(nums[i..j])</code> 组成的递增数组。</p>
> 
> <p>其中，<code>distinct(nums[i..j])</code> 表示从下标 <code>i</code> 到下标 <code>j</code> 的子数组中不同元素的数量。</p>
> 
> <p>返回 <code>nums</code> <strong>唯一性数组 </strong>的 <strong>中位数 </strong>。</p>
> 
> <p><strong>注意</strong>，数组的 <strong>中位数 </strong>定义为有序数组的中间元素。如果有两个中间元素，则取值较小的那个。<!-- notionvc: 7e0f5178-4273-4a82-95ce-3395297921dc --></p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [1,2,3]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code> 的唯一性数组为 <code>[distinct(nums[0..0]), distinct(nums[1..1]), distinct(nums[2..2]), distinct(nums[0..1]), distinct(nums[1..2]), distinct(nums[0..2])]</code>，即 <code>[1, 1, 1, 2, 2, 3]</code> 。唯一性数组的中位数为 1 ，因此答案是 1 。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [3,4,3,4,5]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code> 的唯一性数组为 <code>[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]</code> 。唯一性数组的中位数为 2 ，因此答案是 2 。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [4,3,5,4]</span></p>
> 
> <p><strong>输出：</strong><span class="example-io">2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code> 的唯一性数组为 <code>[1, 1, 1, 1, 2, 2, 2, 3, 3, 3]</code> 。唯一性数组的中位数为 2 ，因此答案是 2 。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d27;

import java.util.HashMap;

class LC3134 {

  class Solution {

    public int medianOfUniquenessArray(int[] nums) {
      int n = nums.length;
      long k = ((long) n * (n + 1) / 2 + 1) / 2;
      int left = 0;
      int right = n;
      while (left + 1 < right) {
        int mid = (left + right) / 2;
        if (check(nums, mid, k)) {
          right = mid;
        } else {
          left = mid;
        }
      }
      return right;
    }

    private boolean check(int[] nums, int upper, long k) {
      long cnt = 0;
      int l = 0;
      HashMap<Integer, Integer> freq = new HashMap<>();
      for (int r = 0; r < nums.length; r++) {
        freq.merge(nums[r], 1, Integer::sum); // 移入右端点
        while (freq.size() > upper) { // 窗口内元素过多
          int out = nums[l++];
          if (freq.merge(out, -1, Integer::sum) == 0) { // 移出左端点
            freq.remove(out);
          }
        }
        cnt += r - l + 1; // 右端点固定为 r 时，有 r-l+1 个合法左端点
        if (cnt >= k) {
          return true;
        }
      }
      return false;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3144

> <p>给你一个字符串&nbsp;<code>s</code>&nbsp;，你需要将它分割成一个或者更多的&nbsp;<strong>平衡</strong>&nbsp;子字符串。比方说，<code>s == "ababcc"</code>&nbsp;那么&nbsp;<code>("abab", "c", "c")</code>&nbsp;，<code>("ab", "abc", "c")</code>&nbsp;和&nbsp;<code>("ababcc")</code>&nbsp;都是合法分割，但是&nbsp;<code>("a", <strong>"bab"</strong>, "cc")</code>&nbsp;，<code>(<strong>"aba"</strong>, "bc", "c")</code>&nbsp;和&nbsp;<code>("ab", <strong>"abcc"</strong>)</code>&nbsp;不是，不平衡的子字符串用粗体表示。</p>
> 
> <p>请你返回 <code>s</code>&nbsp;<strong>最少</strong> 能分割成多少个平衡子字符串。</p>
> 
> <p><b>注意：</b>一个 <strong>平衡</strong>&nbsp;字符串指的是字符串中所有字符出现的次数都相同。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>s = "fabccddg"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>3</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>我们可以将 <code>s</code>&nbsp;分割成 3 个子字符串：<code>("fab, "ccdd", "g")</code>&nbsp;或者&nbsp;<code>("fabc", "cd", "dg")</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>s = "abababaccddb"</span></p>
> 
> <p><span class="example-io"><b>输出：</b>2</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>我们可以将&nbsp;<code>s</code>&nbsp;分割成 2 个子字符串：<code>("abab", "abaccddb")</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 1000</code></li>
> 	<li><code>s</code>&nbsp;只包含小写英文字母。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d28;

import java.util.Arrays;

class LC3144 {

  class Solution {

    public int minimumSubstringsInPartition(String s) {
      int n = s.length();
      int[] dp = new int[n + 1];
      Arrays.fill(dp, Integer.MAX_VALUE);
      dp[0] = 0;
      int[] cnt = new int[26];
      for (int i = 0; i < n; i++) {
        Arrays.fill(cnt, 0);
        int maxCnt = 0;
        int k = 0;
        for (int j = i; j >= 0; j--) {
          int index = s.charAt(j) - 'a';
          k += cnt[index]++ == 0 ? 1 : 0;
          maxCnt = Math.max(maxCnt, cnt[index]);
          if (i - j + 1 == k * maxCnt) {
            dp[i + 1] = Math.min(dp[i + 1], dp[j] + 1);
          }
        }
      }
      return dp[n];
    }

  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3142

> <p>给你一个大小为 <code>m x n</code>&nbsp;的二维矩阵&nbsp;<code>grid</code>&nbsp;。你需要判断每一个格子&nbsp;<code>grid[i][j]</code>&nbsp;是否满足：</p>
> 
> <ul>
> 	<li>如果它下面的格子存在，那么它需要等于它下面的格子，也就是&nbsp;<code>grid[i][j] == grid[i + 1][j]</code>&nbsp;。</li>
> 	<li>如果它右边的格子存在，那么它需要不等于它右边的格子，也就是&nbsp;<code>grid[i][j] != grid[i][j + 1]</code>&nbsp;。</li>
> </ul>
> 
> <p>如果 <strong>所有</strong>&nbsp;格子都满足以上条件，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [[1,0,2],[1,0,2]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>true</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/04/15/examplechanged.png" style="width: 254px; height: 186px;padding: 10px; background: #fff; border-radius: .5rem;" /></strong></p>
> 
> <p>网格图中所有格子都符合条件。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [[1,1,1],[0,0,0]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>false</span></p>
> 
> <p><b>解释：</b></p>
> 
> <p><strong><img alt="" src="https://assets.leetcode.com/uploads/2024/03/27/example21.png" style="width: 254px; height: 186px;padding: 10px; background: #fff; border-radius: .5rem;" /></strong></p>
> 
> <p>同一行中的格子值都相等。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [[1],[2],[3]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>false</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/31/changed.png" style="width: 86px; height: 277px;padding: 10px; background: #fff; border-radius: .5rem;" /></p>
> 
> <p>同一列中的格子值不相等。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n, m &lt;= 10</code></li>
> 	<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d29;

/*
 * https://leetcode.cn/problems/check-if-grid-satisfies-conditions/
 * */
class LC3142 {

  class Solution {

    public boolean satisfiesConditions(int[][] grid) {
      int m = grid.length;
      int n = grid[0].length;
      for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
          if ((i < m - 1 && grid[i][j] != grid[i + 1][j]) || (j < n - 1 && grid[i][j] == grid[i][j
              + 1])) {
            return false;
          }
        }
      }
      return true;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3153

> <p>你有一个数组&nbsp;<code>nums</code>&nbsp;，它只包含 <strong>正</strong>&nbsp;整数，所有正整数的数位长度都 <strong>相同</strong>&nbsp;。</p>
> 
> <p>两个整数的 <strong>数位差</strong>&nbsp;指的是两个整数 <b>相同</b>&nbsp;位置上不同数字的数目。</p>
> 
> <p>请你返回 <code>nums</code>&nbsp;中 <strong>所有</strong>&nbsp;整数对里，<strong>数位差之和。</strong></p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [13,23,12]</span></p>
> 
> <p><b>输出：</b>4</p>
> 
> <p><strong>解释：</strong><br />
> 计算过程如下：<br />
> -&nbsp;<strong>1</strong>3 和&nbsp;<strong>2</strong>3 的数位差为&nbsp;1 。<br />
> - 1<strong>3</strong> 和 1<strong>2</strong>&nbsp;的数位差为&nbsp;1 。<br />
> -&nbsp;<strong>23</strong> 和&nbsp;<strong>12</strong>&nbsp;的数位差为&nbsp;2 。<br />
> 所以所有整数数对的数位差之和为&nbsp;<code>1 + 1 + 2 = 4</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [10,10,10,10]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>0</span></p>
> 
> <p><strong>解释：</strong><br />
> 数组中所有整数都相同，所以所有整数数对的数位不同之和为 0 。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt; 10<sup>9</sup></code></li>
> 	<li><code>nums</code>&nbsp;中的整数都有相同的数位长度。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d30;

class LC3153 {

  static class Solution {

    public long sumDigitDifferences(int[] nums) {
      long ans = 0L;
      int n = nums.length;
      int len = String.valueOf(nums[0]).length();
      int[][] cnt = new int[len][10];
      for (int i = 0; i < len; i++) {
        for (int j = 0; j < n; j++) {
          cnt[i][nums[j] % 10]++;
          nums[j] /= 10;
        }
      }
      for (int[] line : cnt) {
        for (int i = 0; i < 10; i++) {
          for (int j = i + 1; j < 10; j++) {
            if (line[i] > 0 && line[j] > 0) {
              ans += (long) line[i] * line[j];
            }
          }
        }
      }
      return ans;
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3127

> <p>给你一个二维 <code>3 x 3</code>&nbsp;的矩阵&nbsp;<code>grid</code>&nbsp;，每个格子都是一个字符，要么是&nbsp;<code>'B'</code>&nbsp;，要么是&nbsp;<code>'W'</code>&nbsp;。字符&nbsp;<code>'W'</code>&nbsp;表示白色，字符&nbsp;<code>'B'</code>&nbsp;表示黑色。</p>
> 
> <p>你的任务是改变 <strong>至多一个</strong>&nbsp;格子的颜色，使得矩阵中存在一个 <code>2 x 2</code>&nbsp;颜色完全相同的正方形。<!-- notionvc: adf957e1-fa0f-40e5-9a2e-933b95e276a7 --></p>
> 
> <p>如果可以得到一个相同颜色的 <code>2 x 2</code>&nbsp;正方形，那么返回 <code>true</code>&nbsp;，否则返回 <code>false</code>&nbsp;。</p>
> 
> <p>&nbsp;</p>
> <style type="text/css">.grid-container {
>   display: grid;
>   grid-template-columns: 30px 30px 30px;
>   padding: 10px;
> }
> .grid-item {
>   background-color: black;
>   border: 1px solid gray;
>   height: 30px;
>   font-size: 30px;
>   text-align: center;
> }
> .grid-item-white {
>   background-color: white;
> }
> </style>
> <style class="darkreader darkreader--sync" media="screen" type="text/css">
> </style>
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="grid-container">
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> </div>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [["B","W","B"],["B","W","W"],["B","W","B"]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>true</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>修改&nbsp;<code>grid[0][2]</code> 的颜色，可以满足要求。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="grid-container">
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> </div>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [["B","W","B"],["W","B","W"],["B","W","B"]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>false</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>只改变一个格子颜色无法满足要求。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="grid-container">
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> 
> <div class="grid-item grid-item-white">&nbsp;</div>
> </div>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>grid = [["B","W","B"],["B","W","W"],["B","W","W"]]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>true</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>grid</code>&nbsp;已经包含一个&nbsp;<code>2 x 2</code>&nbsp;颜色相同的正方形了。<!-- notionvc: 9a8b2d3d-1e73-457a-abe0-c16af51ad5c2 --></p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>grid.length == 3</code></li>
> 	<li><code>grid[i].length == 3</code></li>
> 	<li><code>grid[i][j]</code>&nbsp;要么是&nbsp;<code>'W'</code>&nbsp;，要么是&nbsp;<code>'B'</code> 。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m08.d31;

class LC3127 {

  class Solution {

    public boolean canMakeSquare(char[][] grid) {
      int[][] dirs = new int[][]{{0, 0}, {0, 1}, {1, 0}, {1, 1}};
      for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
          int[] cnt = new int[2];
          for (int[] dir : dirs) {
            if (grid[i + dir[0]][j + dir[1]] == 'B') {
              cnt[0]++;
            } else {
              cnt[1]++;
            }
          }
          if (cnt[0] != cnt[1]) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
```
</li>
</ul>
</li>
</ol>
