<ol>
<li>
<ul>
<li>保持城市天际线

> <p>给你一座由 <code>n x n</code> 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 <strong>0</strong> 开始的 <code>n x n</code> 整数矩阵 <code>grid</code> ，其中 <code>grid[r][c]</code> 表示坐落于 <code>r</code> 行 <code>c</code> 列的建筑物的 <strong>高度</strong> 。</p>
> 
> <p>城市的 <strong>天际线</strong> 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 <strong>天际线</strong> 可能不同。</p>
> 
> <p>我们被允许为 <strong>任意数量的建筑物 </strong>的高度增加<strong> 任意增量（不同建筑物的增量可能不同）</strong> 。 高度为 <code>0</code> 的建筑物的高度也可以增加。然而，增加的建筑物高度 <strong>不能影响</strong> 从任何主要方向观察城市得到的 <strong>天际线</strong> 。</p>
> 
> <p>在 <strong>不改变</strong> 从任何主要方向观测到的城市 <strong>天际线</strong> 的前提下，返回建筑物可以增加的 <strong>最大高度增量总和</strong> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> <img alt="" src="https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png" style="width: 700px; height: 603px;" />
> <pre>
> <strong>输入：</strong>grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
> <strong>输出：</strong>35
> <strong>解释：</strong>建筑物的高度如上图中心所示。
> 用红色绘制从不同方向观看得到的天际线。
> 在不影响天际线的情况下，增加建筑物的高度：
> gridNew = [ [8, 4, 8, 7],
>             [7, 4, 7, 7],
>             [9, 4, 8, 7],
>             [3, 3, 3, 3] ]
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>grid = [[0,0,0],[0,0,0],[0,0,0]]
> <strong>输出：</strong>0
> <strong>解释：</strong>增加任何建筑物的高度都会导致天际线的变化。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>n == grid.length</code></li>
> 	<li><code>n == grid[r].length</code></li>
> 	<li><code>2 &lt;= n &lt;= 50</code></li>
> 	<li><code>0 &lt;= grid[r][c] &lt;= 100</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d14;

class LC807 {

  // 贪心思想，使每个方格增长为 Min(行最大值,列最大值) 即可
  public int maxIncreaseKeepingSkyline(int[][] grid) {
    int ans = 0;
    int rows = grid.length;
    int cols = grid[0].length;
    int[] rowMax = new int[rows];
    int[] colMax = new int[cols];
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < cols; j++) {
        rowMax[i] = Math.max(rowMax[i], grid[i][j]);
        colMax[j] = Math.max(colMax[j], grid[i][j]);
      }
    }
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < cols; j++) {
        int tempMin = Math.min(rowMax[i], colMax[j]);
//        System.out.print(tempMin+",");
        if (tempMin > grid[i][j]) {
          ans += tempMin - grid[i][j];
        }
      }
//      System.out.println("");
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>账户合并

> <p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>&nbsp;是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code>&nbsp;是&nbsp;<em>名称 (name)</em>，其余元素是 <em><strong>emails</strong> </em>表示该账户的邮箱地址。</p>
> 
> <p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>
> 
> <p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 <strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以 <strong>任意顺序</strong> 返回。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
> <b>输出：</b>[["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
> <b>解释：</b>
> 第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 "johnsmith@mail.com"。 
> 第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。
> 可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，
> ['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
> <strong>输出：</strong>[["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>
> 	<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>
> 	<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>
> 	<li><code>accounts[i][0]</code> 由英文字母组成</li>
> 	<li><code>accounts[i][j] (for j &gt; 0)</code> 是有效的邮箱地址</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d15;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

class LC721 {

  //  并查集
  public List<List<String>> accountsMerge(List<List<String>> accounts) {
    List<List<String>> ans = new ArrayList<>();
    if (accounts.size() == 0) {
      return ans;
    }
    Map<String, Integer> emailToIndex = new HashMap<>();
    Map<String, String> emailToName = new HashMap<>();
    int emai_ount = 0;
    for (List<String> account : accounts) {
      String name = account.get(0);
      for (int i = 1; i < account.size(); i++) {
        String emailItem = account.get(i);
        if (!emailToIndex.containsKey(emailItem)) {
          emailToIndex.put(emailItem, emai_ount++);
          emailToName.put(emailItem, name);
        }
      }
    }

    UnionFind uf = new UnionFind(emai_ount);
    for (List<String> account : accounts) {
      int firstIndex = emailToIndex.get(account.get(1));
      for (int i = 2; i < account.size(); i++) {
        int nextIndex = emailToIndex.get(account.get(i));
        uf.union(firstIndex, nextIndex);
      }
    }

    Map<Integer, List<String>> indexToEmails = new HashMap<>();
    for (Entry<String, Integer> item : emailToIndex.entrySet()) {
      int index = uf.find(item.getValue());
      String email = item.getKey();
      List<String> emails = indexToEmails.getOrDefault(index, new ArrayList<>());
      emails.add(email);
      indexToEmails.put(index, emails);
    }
    for (List<String> emails : indexToEmails.values()) {
      Collections.sort(emails);
      String name = emailToName.get(emails.get(0));
      List<String> account = new ArrayList<>();
      account.add(name);
      account.addAll(emails);
      ans.add(account);
    }
    return ans;
  }

  class UnionFind {

    int[] parent;

    public UnionFind(int n) {
      parent = new int[n];
      for (int i = 0; i < parent.length; i++) {
        parent[i] = i;
      }
    }

    public int find(int index) {
      if (parent[index] != index) {
        parent[index] = find(parent[index]);
      }
      return parent[index];
    }

    public void union(int index1, int index2) {
      parent[find(index1)] = find(index2);
    }
  }
}

```
</li>
</ul>
</li>
<li>
<ul>
<li>关闭分部的可行集合数目

> <p>一个公司在全国有 <code>n</code>&nbsp;个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达。</p>
> 
> <p>公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（<b>也可能不关闭任何分部</b>），同时保证剩下的分部之间两两互相可以到达且最远距离不超过&nbsp;<code>maxDistance</code>&nbsp;。</p>
> 
> <p>两个分部之间的 <strong>距离</strong> 是通过道路长度之和的 <strong>最小值</strong>&nbsp;。</p>
> 
> <p>给你整数&nbsp;<code>n</code>&nbsp;，<code>maxDistance</code>&nbsp;和下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>roads</code>&nbsp;，其中&nbsp;<code>roads[i] = [u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>]</code>&nbsp;表示一条从&nbsp;<code>u<sub>i</sub></code>&nbsp;到&nbsp;<code>v<sub>i</sub></code>&nbsp;长度为&nbsp;<code>w<sub>i</sub></code>的&nbsp;<strong>无向</strong>&nbsp;道路。</p>
> 
> <p>请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过<em>&nbsp;</em><code>maxDistance</code>。</p>
> 
> <p><strong>注意</strong>，关闭一个分部后，与之相连的所有道路不可通行。</p>
> 
> <p><b>注意</b>，两个分部之间可能会有多条道路。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2023/11/08/example11.png" style="width: 221px; height: 191px;" /></p>
> 
> <pre>
> <b>输入：</b>n = 3, maxDistance = 5, roads = [[0,1,2],[1,2,10],[0,2,10]]
> <b>输出：</b>5
> <b>解释：</b>可行的关闭分部方案有：
> - 关闭分部集合 [2] ，剩余分部为 [0,1] ，它们之间的距离为 2 。
> - 关闭分部集合 [0,1] ，剩余分部为 [2] 。
> - 关闭分部集合 [1,2] ，剩余分部为 [0] 。
> - 关闭分部集合 [0,2] ，剩余分部为 [1] 。
> - 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。
> 总共有 5 种可行的关闭方案。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2023/11/08/example22.png" style="width: 221px; height: 241px;" /></p>
> 
> <pre>
> <b>输入：</b>n = 3, maxDistance = 5, roads = [[0,1,20],[0,1,10],[1,2,2],[0,2,2]]
> <b>输出：</b>7
> <b>解释：</b>可行的关闭分部方案有：
> - 关闭分部集合 [] ，剩余分部为 [0,1,2] ，它们之间的最远距离为 4 。
> - 关闭分部集合 [0] ，剩余分部为 [1,2] ，它们之间的距离为 2 。
> - 关闭分部集合 [1] ，剩余分部为 [0,2] ，它们之间的距离为 2 。
> - 关闭分部集合 [0,1] ，剩余分部为 [2] 。
> - 关闭分部集合 [1,2] ，剩余分部为 [0] 。
> - 关闭分部集合 [0,2] ，剩余分部为 [1] 。
> - 关闭分部集合 [0,1,2] ，关闭后没有剩余分部。
> 总共有 7 种可行的关闭方案。
> </pre>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <pre>
> <b>输入：</b>n = 1, maxDistance = 10, roads = []
> <b>输出：</b>2
> <b>解释：</b>可行的关闭分部方案有：
> - 关闭分部集合 [] ，剩余分部为 [0] 。
> - 关闭分部集合 [0] ，关闭后没有剩余分部。
> 总共有 2 种可行的关闭方案。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 10</code></li>
> 	<li><code>1 &lt;= maxDistance &lt;= 10<sup>5</sup></code></li>
> 	<li><code>0 &lt;= roads.length &lt;= 1000</code></li>
> 	<li><code>roads[i].length == 3</code></li>
> 	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
> 	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
> 	<li><code>1 &lt;= w<sub>i</sub> &lt;= 1000</code></li>
> 	<li>一开始所有分部之间通过道路互相可以到达。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d17;

import java.util.Arrays;

/*
 * https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/description/
 * */
class LC2959 {

  public int numberOfSets(int n, int maxDistance, int[][] roads) {
    int[][] m = new int[n][n];
    int ans = 0;
    int[] opened = new int[n];
    //枚举所有关闭的方案
    for (int mask = 0; mask < (1 << n); mask++) {
      //初始化门店开关状态
      for (int i = 0; i < n; i++) {
        opened[i] = mask & (1 << i);
      }
      //初始化门店距离矩阵
      for (int i = 0; i < n; i++) {
        int[] row = m[i];
        Arrays.fill(row, 100000);
      }
      //填充矩阵
      for (int[] road : roads) {
        int i = road[0];
        int j = road[1];
        int distance = road[2];
        if (opened[i] > 0 && opened[j] > 0) {
          m[i][j] = m[j][i] = Math.min(m[i][j], distance);
        }
      }
      /*floyd算法，寻找多源最短路径*/
      for (int k = 0; k < n; k++) {
        if (opened[k] > 0) {
          for (int i = 0; i < n; i++) {
            if (opened[i] > 0) {
              for (int j = i + 1; j < n; j++) {
                if (opened[j] > 0) {
                  m[i][j] = m[j][i] = Math.min(m[i][j], m[i][k] + m[k][j]);
                }
              }
            }
          }
        }
      }

      boolean success = true;
      //计算此次方案是否有超出maxDistance距离的门店
      for (int i = 0; success && i < n; i++) {
        if (opened[i] > 0) {
          for (int j = i + 1; success && j < n; j++) {
            if (opened[i] > 0) {
              if (m[i][j] > maxDistance) {
                success = false;
              }
            }
          }
        }
      }
      /*将符合条件的方案加上*/
      ans += success ? 1 : 0;
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3112

> <p>给你一个二维数组 <code>edges</code>&nbsp;表示一个 <code>n</code>&nbsp;个点的无向图，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code>&nbsp;表示节点&nbsp;<code>u<sub>i</sub></code> 和节点&nbsp;<code>v<sub>i</sub></code>&nbsp;之间有一条需要&nbsp;<code>length<sub>i</sub></code>&nbsp;单位时间通过的无向边。</p>
> 
> <p>同时给你一个数组&nbsp;<code>disappear</code>&nbsp;，其中&nbsp;<code>disappear[i]</code>&nbsp;表示节点 <code>i</code>&nbsp;从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。</p>
> 
> <p><strong>注意</strong>，图有可能一开始是不连通的，两个节点之间也可能有多条边。</p>
> 
> <p>请你返回数组&nbsp;<code>answer</code>&nbsp;，<code>answer[i]</code>&nbsp;表示从节点 <code>0</code>&nbsp;到节点 <code>i</code>&nbsp;需要的 <strong>最少</strong>&nbsp;单位时间。如果从节点 <code>0</code>&nbsp;出发 <strong>无法</strong> 到达节点 <code>i</code>&nbsp;，那么 <code>answer[i]</code>&nbsp;为 <code>-1</code>&nbsp;。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <p><img 10px="" alt="" padding:="" src="https://assets.leetcode.com/uploads/2024/03/09/example1.png" style="width: 350px; height: 210px;" /></p>
> 
> <div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
> <p style=""><span class="example-io"><b>输入：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]</span></p>
> 
> <p style=""><span class="example-io"><b>输出：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">[0,-1,4]</span></p>
> 
> <p style="font-size: 0.875rem;"><strong>解释：</strong></p>
> 
> <p style="font-size: 0.875rem;">我们从节点 0 出发，目的是用最少的时间在其他节点消失之前到达它们。</p>
> 
> <ul style="font-size: 0.875rem;">
> 	<li>对于节点 0 ，我们不需要任何时间，因为它就是我们的起点。</li>
> 	<li>对于节点 1 ，我们需要至少 2 单位时间，通过&nbsp;<code>edges[0]</code>&nbsp;到达。但当我们到达的时候，它已经消失了，所以我们无法到达它。</li>
> 	<li>对于节点 2 ，我们需要至少 4 单位时间，通过&nbsp;<code>edges[2]</code>&nbsp;到达。</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <p><img 10px="" alt="" padding:="" src="https://assets.leetcode.com/uploads/2024/03/09/example2.png" style="width: 350px; height: 210px;" /></p>
> 
> <div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
> <p style=""><span class="example-io"><b>输入：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]</span></p>
> 
> <p style=""><span class="example-io"><b>输出：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">[0,2,3]</span></p>
> 
> <p style="font-size: 0.875rem;"><strong>解释：</strong></p>
> 
> <p style="font-size: 0.875rem;">我们从节点 0 出发，目的是用最少的时间在其他节点消失之前到达它们。</p>
> 
> <ul style="font-size: 0.875rem;">
> 	<li>对于节点 0 ，我们不需要任何时间，因为它就是我们的起点。</li>
> 	<li>对于节点 1 ，我们需要至少 2 单位时间，通过&nbsp;<code>edges[0]</code>&nbsp;到达。</li>
> 	<li>对于节点 2&nbsp;，我们需要至少 3&nbsp;单位时间，通过&nbsp;<code>edges[0]</code>&nbsp;和 <code>edges[1]</code>&nbsp;到达。</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
> <p><span class="example-io"><b>输入：</b>n = 2, edges = [[0,1,1]], disappear = [1,1]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>[0,-1]</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>当我们到达节点 1 的时候，它恰好消失，所以我们无法到达节点 1 。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
> 	<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>edges[i] == [u<sub>i</sub>, v<sub>i</sub>, length<sub>i</sub>]</code></li>
> 	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n - 1</code></li>
> 	<li><code>1 &lt;= length<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
> 	<li><code>disappear.length == n</code></li>
> 	<li><code>1 &lt;= disappear[i] &lt;= 10<sup>5</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d18;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

class LC3112 {

  //  稀疏图 用邻接表和dijkstra(迪拉杰斯特)算法
  public int[] minimumTime(int n, int[][] edges, int[] disappear) {
    List<int[]>[] g = new ArrayList[n];
    Arrays.setAll(g, i -> new ArrayList<>());
    for (int[] edge : edges) {
      int u = edge[0];
      int v = edge[1];
      int length = edge[2];
      g[u].add(new int[]{v, length});
      g[v].add(new int[]{u, length});
    }
    int[] dis = new int[n];
    Arrays.fill(dis, -1);
    dis[0] = 0;
    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
    pq.offer(new int[]{0, 0});
    while (!pq.isEmpty()) {
      int[] p = pq.poll();
      int x = p[0];
      int dx = p[1];
      if (dx > dis[x]) {
        continue;
      }
      for (int[] item : g[x]) {
        int y = item[0];
        int newDis = dis[x] + item[1];
        if (newDis < disappear[y] && (dis[y] < 0 || newDis < dis[y])) {
          dis[y] = newDis;
          pq.offer(new int[]{y, newDis});
        }
      }
    }
    return dis;
  }

}
```
</li>
</ul>
</li>
<li>
<ul>
<li>得到更多分数的最少关卡数目

> <p>给你一个长度为 <code>n</code>&nbsp;的二进制数组&nbsp;<code>possible</code>&nbsp;。</p>
> 
> <p>莉叩酱和冬坂五百里正在玩一个有 <code>n</code> 个关卡的游戏，游戏中有一些关卡是 <strong>困难</strong>&nbsp;模式，其他的关卡是 <strong>简单</strong>&nbsp;模式。如果&nbsp;<code>possible[i] == 0</code>&nbsp;，那么第&nbsp;<code>i</code> 个关卡是 <strong>困难</strong>&nbsp;模式。一个玩家通过一个简单模式的关卡可以获得 <code>1</code>&nbsp;分，通过困难模式的关卡将失去 <code>1</code>&nbsp;分。</p>
> 
> <p>游戏的一开始，莉叩酱将从第 <code>0</code>&nbsp;级开始 <strong>按顺序</strong> 完成一些关卡，然后冬坂五百里会完成剩下的所有关卡。</p>
> 
> <p>假设两名玩家都采取最优策略，目的是&nbsp;<strong>最大化</strong>&nbsp;自己的得分，莉叩酱想知道自己&nbsp;<strong>最少</strong> 需要完成多少个关卡，才能获得比冬坂五百里更多的分数。</p>
> 
> <p>请你返回莉叩酱获得比冬坂五百里更多的分数所需要完成的 <strong>最少</strong> 关卡数目，如果 <strong>无法</strong>&nbsp;达成，那么返回 <code>-1</code>&nbsp;。</p>
> 
> <p><strong>注意</strong>，每个玩家都至少需要完成&nbsp;<code>1</code> 个关卡。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>possible = [1,0,1,0]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>我们来看一下莉叩酱可以完成的关卡数目：</p>
> 
> <ul>
> 	<li>如果莉叩酱只完成关卡 0 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 1 分，冬坂五百里获得 -1 + 1 - 1 = -1 分。</li>
> 	<li>如果莉叩酱完成到关卡 1 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得&nbsp;1 - 1 = 0 分，冬坂五百里获得 1 - 1 = 0 分。</li>
> 	<li>如果莉叩酱完成到关卡 2 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得&nbsp;1 - 1 + 1 = 1 分，冬坂五百里获得 -1 分。</li>
> </ul>
> 
> <p>莉叩酱需要完成至少一个关卡获得更多的分数。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>possible = [1,1,1,1,1]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>3</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>我们来看一下莉叩酱可以完成的关卡数目：</p>
> 
> <ul>
> 	<li>如果莉叩酱只完成关卡 0 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 1 分，冬坂五百里获得 4 分。</li>
> 	<li>如果莉叩酱完成到关卡 1 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得&nbsp;2 分，冬坂五百里获得 3 分。</li>
> 	<li>如果莉叩酱完成到关卡 2 ，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得&nbsp;3 分，冬坂五百里获得 2&nbsp;分。</li>
> 	<li>如果莉叩酱完成到关卡 3&nbsp;，冬坂五百里完成剩下的所有关卡，那么莉叩酱获得 4&nbsp;分，冬坂五百里获得 1&nbsp;分。</li>
> </ul>
> 
> <p>莉叩酱需要完成至少三个关卡获得更多的分数。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>possible = [0,0]</span></p>
> 
> <p><span class="example-io"><b>输出：</b>-1</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p>两名玩家只能各完成 1 个关卡，莉叩酱完成关卡 0 得到 -1 分，冬坂五百里完成关卡 1 得到 -1 分。两名玩家得分相同，所以莉叩酱无法得到更多分数。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= n == possible.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>possible[i]</code>&nbsp;要么是&nbsp;<code>0</code>&nbsp;要么是&nbsp;<code>1</code> 。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d19;

class LC3096 {

  // 前缀和问题
  public int minimumLevels(int[] possible) {
    int ans = -1;
    int n = possible.length;
    int[] a = new int[n];
    int[] b = new int[n];
    a[0] = possible[0] == 1 ? 1 : -1;
    b[n - 1] = possible[n - 1] == 1 ? 1 : -1;
    for (int i = 1; i < n; i++) {
      if (possible[i] == 1) {
        a[i] = a[i - 1] + 1;
      } else {
        a[i] = a[i - 1] - 1;
      }
      if (possible[(n - 1) - i] == 1) {
        b[(n - 1) - i] = b[(n - 1) - i + 1] + 1;
      } else {
        b[(n - 1) - i] = b[(n - 1) - i + 1] - 1;
      }
    }
    for (int i = 0; i < n - 1; i++) {
      if (a[i] - b[i + 1] > 0) {
        ans = i + 1;
        break;
      }
    }
    return ans;
  }

  //  优化空间写法
  public int minimumLevels1(int[] possible) {
    int n = possible.length;
//    所有题的总分数
    int total = 0;
    for (int j : possible) {
      total += j == 1 ? 1 : -1;
    }
//    a所得分数
    int score = 0;
    for (int i = 0; i < n - 1; i++) {
      score += possible[i] == 1 ? 1 : -1;
      if (score > total - score) {
        return i + 1;
      }
    }
    return -1;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>将石头分散到网格图的最少移动次数

> <p>给你一个大小为 <code>3 * 3</code>&nbsp;，下标从 <strong>0</strong>&nbsp;开始的二维整数矩阵&nbsp;<code>grid</code>&nbsp;，分别表示每一个格子里石头的数目。网格图中总共恰好有&nbsp;<code>9</code>&nbsp;个石头，一个格子里可能会有 <strong>多个</strong>&nbsp;石头。</p>
> 
> <p>每一次操作中，你可以将一个石头从它当前所在格子移动到一个至少有一条公共边的相邻格子。</p>
> 
> <p>请你返回每个格子恰好有一个石头的 <strong>最少移动次数</strong>&nbsp;。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2023/08/23/example1-3.svg" style="width: 401px; height: 281px;" /></p>
> 
> <pre>
> <b>输入：</b>grid = [[1,1,0],[1,1,1],[1,2,1]]
> <b>输出：</b>3
> <b>解释：</b>让每个格子都有一个石头的一个操作序列为：
> 1 - 将一个石头从格子 (2,1) 移动到 (2,2) 。
> 2 - 将一个石头从格子 (2,2) 移动到 (1,2) 。
> 3 - 将一个石头从格子 (1,2) 移动到 (0,2) 。
> 总共需要 3 次操作让每个格子都有一个石头。
> 让每个格子都有一个石头的最少操作次数为 3 。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2023/08/23/example2-2.svg" style="width: 401px; height: 281px;" /></p>
> 
> <pre>
> <b>输入：</b>grid = [[1,3,0],[1,0,0],[1,0,3]]
> <b>输出：</b>4
> <b>解释：</b>让每个格子都有一个石头的一个操作序列为：
> 1 - 将一个石头从格子 (0,1) 移动到 (0,2) 。
> 2 - 将一个石头从格子 (0,1) 移动到 (1,1) 。
> 3 - 将一个石头从格子 (2,2) 移动到 (1,2) 。
> 4 - 将一个石头从格子 (2,2) 移动到 (2,1) 。
> 总共需要 4 次操作让每个格子都有一个石头。
> 让每个格子都有一个石头的最少操作次数为 4 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>grid.length == grid[i].length == 3</code></li>
> 	<li><code>0 &lt;= grid[i][j] &lt;= 9</code></li>
> 	<li><code>grid</code>&nbsp;中元素之和为&nbsp;<code>9</code> 。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d20;

import java.util.ArrayList;
import java.util.List;

//  https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/description/
class LC2850 {

  // dfs 回溯   (提前剪枝的枚举)
  public int minimumMoves(int[][] grid) {
    List<int[]> zeros = new ArrayList<>();
    List<int[]> needMoved = new ArrayList<>();
    for (int i = 0; i < grid.length; i++) {
      int[] row = grid[i];
      for (int j = 0; j < row.length; j++) {
        int item = row[j];
        if (item == 0) {
          zeros.add(new int[]{i, j});
        }
        if (item > 1) {
          needMoved.add(new int[]{i, j});
        }
      }
    }
    return dfs(needMoved, zeros, grid, 0, 0);
  }

  public int dfs(List<int[]> needMoved, List<int[]> zeros, int[][] grid, int index, int step) {
    if (index == zeros.size()) {
      return step;
    }
    int ans = Integer.MAX_VALUE;
    for (int k = 0; k < needMoved.size(); k++) {
      int i = needMoved.get(k)[0];
      int j = needMoved.get(k)[1];
      if (grid[i][j] > 1) {
        grid[i][j]--;
        int subStep = Math.abs(i - zeros.get(index)[0]) + Math.abs(j - zeros.get(index)[1]);
        ans = Math.min(ans, dfs(needMoved, zeros, grid, index + 1, step + subStep));
        grid[i][j]++;
      }
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>删除一次得到子数组最大和

> <p>给你一个整数数组，返回它的某个&nbsp;<strong>非空</strong> 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p>
> 
> <p>注意，删除一个元素后，子数组 <strong>不能为空</strong>。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>arr = [1,-2,0,3]
> <strong>输出：</strong>4
> <strong>解释：</strong>我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>arr = [1,-2,-2,3]
> <strong>输出：</strong>3
> <strong>解释：</strong>我们直接选出 [3]，这就是最大和。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>arr = [-1,-1,-1,-1]
> <strong>输出：</strong>-1
> <strong>解释：</strong>最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
>      我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> <meta charset="UTF-8" />
> 
> <ul>
> 	<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i] &lt;= 10<sup>4</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d21;

//  https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/
class LC1186 {

  //弄懂这个个基础是先学会求连续最大子数组(Kadane‘s算法): https://blog.csdn.net/weixin_43764974/article/details/134513506
//  核心是dp[i] 表示以arr[i]结尾的最大子数组和，那么dp[i]的表示就只有两种可能
//  1. dp[i] = dp[i-1]+arr[i]  ,这种是直接拼接之前的数组
//  2. dp[i] = arr[i]   .当dp[i-1]<0的时候, 直接放弃前面的数组, 以当前元素为此时的最大和
//  因此dp[i] = max(dp[i-1]+arr[i],arr[i]) 或者表示成: dp[i] = max(dp[i-1],0) + arr[i]
  public int maximumSum(int[] arr) {
//    因为在递推过程中, 当前状态只和前一个状态有关, 所以二维dp数组dp[i][0]和dp[i][1]就简化成了dp0和dp1
//    dp0表示不删除元素时的当前最大子数组和
    int dp0 = arr[0];
//    dp1表示删除一个元素时的当前最大子数组和
    int dp1 = 0;
//    i = 1时, 因为题目要求最少要一个元素, 所以ans只能时dp0
    int ans = dp0;
    for (int i = 1; i < arr.length; i++) {
//      当选择删除一个元素时, 就出现了两种情况：
//      1. 删除dp中的元素: 那就只能选dp[i-1][1] , 这时候就不能舍弃i之前的dp和了, 如果舍弃, 就不符合删除一个元素的情况了, 所以只能时dp[i-1][1]+arr[i];
//      2. 删除arr[i]: 这时候只能选dp[i-1][o], 并且不能舍弃, 舍弃了就剩空数组了, 不符合题意, 所以只能时dp[i-1][0];
//      最后两者取最大值即得到: Math.max(dp1 + arr[i], dp0);
      dp1 = Math.max(dp1 + arr[i], dp0);
//      当选择不删除元素时, 只能从前面不删除元素的dp中找, 也就是dp[i-1][0], 这时候套用求连续最大子数组的公式即得到 dp0 = Math.max(dp0 + arr[i], arr[i]);
      dp0 = Math.max(dp0 + arr[i], arr[i]);
//      全局更新一下最大和即可
      ans = Math.max(ans, Math.max(dp0, dp1));
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>引爆最多的炸弹

> <p>给你一个炸弹列表。一个炸弹的 <strong>爆炸范围</strong>&nbsp;定义为以炸弹为圆心的一个圆。</p>
> 
> <p>炸弹用一个下标从 <strong>0</strong>&nbsp;开始的二维整数数组&nbsp;<code>bombs</code>&nbsp;表示，其中&nbsp;<code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>&nbsp;。<code>x<sub>i</sub></code> 和&nbsp;<code>y<sub>i</sub></code>&nbsp;表示第 <code>i</code>&nbsp;个炸弹的 X 和 Y 坐标，<code>r<sub>i</sub></code>&nbsp;表示爆炸范围的 <strong>半径</strong>&nbsp;。</p>
> 
> <p>你需要选择引爆 <strong>一个&nbsp;</strong>炸弹。当这个炸弹被引爆时，<strong>所有</strong> 在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆。</p>
> 
> <p>给你数组&nbsp;<code>bombs</code>&nbsp;，请你返回在引爆&nbsp;<strong>一个</strong>&nbsp;炸弹的前提下，<strong>最多</strong>&nbsp;能引爆的炸弹数目。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png" style="width: 300px; height: 300px;"></p>
> 
> <pre><b>输入：</b>bombs = [[2,1,3],[6,1,4]]
> <b>输出：</b>2
> <strong>解释：</strong>
> 上图展示了 2 个炸弹的位置和爆炸范围。
> 如果我们引爆左边的炸弹，右边的炸弹不会被影响。
> 但如果我们引爆右边的炸弹，两个炸弹都会爆炸。
> 所以最多能引爆的炸弹数目是 max(1, 2) = 2 。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png" style="width: 300px; height: 300px;"></p>
> 
> <pre><b>输入：</b>bombs = [[1,1,5],[10,10,5]]
> <b>输出：</b>1
> <strong>解释：
> </strong>引爆任意一个炸弹都不会引爆另一个炸弹。所以最多能引爆的炸弹数目为 1 。
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png" style="width: 300px; height: 300px;"></p>
> 
> <pre><b>输入：</b>bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
> <b>输出：</b>5
> <strong>解释：</strong>
> 最佳引爆炸弹为炸弹 0 ，因为：
> - 炸弹 0 引爆炸弹 1 和 2 。红色圆表示炸弹 0 的爆炸范围。
> - 炸弹 2 引爆炸弹 3 。蓝色圆表示炸弹 2 的爆炸范围。
> - 炸弹 3 引爆炸弹 4 。绿色圆表示炸弹 3 的爆炸范围。
> 所以总共有 5 个炸弹被引爆。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>
> 	<li><code>bombs[i].length == 3</code></li>
> 	<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d22;

import java.util.HashSet;
import java.util.Set;

/*
 * https://leetcode.cn/problems/detonate-the-maximum-bombs/description/
 * */
class LC2101 {

  // floyd算法, 求解多源最短路径
  public int maximumDetonation(int[][] bombs) {
    int n = bombs.length;
    Set<Integer>[] sets = new HashSet[n];
    for (int i = 0; i < n; i++) {
      long x1 = bombs[i][0];
      long y1 = bombs[i][1];
      long r1 = bombs[i][2];
      sets[i] = new HashSet<>();
      for (int j = 0; j < n; j++) {
        long x2 = bombs[j][0];
        long y2 = bombs[j][1];
        long distance = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
        if (distance <= r1 * r1) {
          sets[i].add(j);
        }
      }
    }
    for (int k = 0; k < n; k++) {
      for (int m = 0; m < n; m++) {
        if (sets[m].contains(k)) {
          sets[m].addAll(sets[k]);
        }
      }
    }
    int ans = 0;
    for (Set<Integer> set : sets) {
      ans = Math.max(ans, set.size());
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>求出所有子序列的能量和

> <p>给你一个长度为 <code>n</code>&nbsp;的整数数组&nbsp;<code>nums</code>&nbsp;和一个 <strong>正</strong>&nbsp;整数&nbsp;<code>k</code>&nbsp;。</p>
> 
> <p>一个子序列的 <strong>能量</strong>&nbsp;定义为子序列中&nbsp;<strong>任意</strong>&nbsp;两个元素的差值绝对值的 <strong>最小值</strong>&nbsp;。</p>
> 
> <p>请你返回 <code>nums</code>&nbsp;中长度 <strong>等于</strong>&nbsp;<code>k</code>&nbsp;的 <strong>所有</strong>&nbsp;子序列的 <strong>能量和</strong>&nbsp;。</p>
> 
> <p>由于答案可能会很大，将答案对&nbsp;<code>10<sup>9 </sup>+ 7</code>&nbsp;<strong>取余</strong>&nbsp;后返回。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [1,2,3,4], k = 3</span></p>
> 
> <p><span class="example-io"><b>输出：</b>4</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code>&nbsp;中总共有 4 个长度为 3 的子序列：<code>[1,2,3]</code>&nbsp;，<code>[1,3,4]</code>&nbsp;，<code>[1,2,4]</code>&nbsp;和&nbsp;<code>[2,3,4]</code>&nbsp;。能量和为 <code>|2 - 3| + |3 - 4| + |2 - 1| + |3 - 4| = 4</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <div class="example-block">
> <p><span class="example-io"><b>输入：</b>nums = [2,2], k = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>0</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code>&nbsp;中唯一一个长度为 2 的子序列是&nbsp;<code>[2,2]</code>&nbsp;。能量和为&nbsp;<code>|2 - 2| = 0</code>&nbsp;。</p>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <div class="example-block">
> <p><strong>输入：</strong><span class="example-io">nums = [4,3,-1], k = 2</span></p>
> 
> <p><span class="example-io"><b>输出：</b>10</span></p>
> 
> <p><strong>解释：</strong></p>
> 
> <p><code>nums</code>&nbsp;总共有 3 个长度为 2 的子序列：<code>[4,3]</code>&nbsp;，<code>[4,-1]</code>&nbsp;和&nbsp;<code>[3,-1]</code>&nbsp;。能量和为&nbsp;<code>|4 - 3| + |4 - (-1)| + |3 - (-1)| = 10</code>&nbsp;。</p>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= n == nums.length &lt;= 50</code></li>
> 	<li><code>-10<sup>8</sup> &lt;= nums[i] &lt;= 10<sup>8</sup> </code></li>
> 	<li><code>2 &lt;= k &lt;= n</code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d23;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/*
 * https://leetcode.cn/problems/find-the-sum-of-subsequence-powers/description/
 * */
class LC3098 {

  int[] nums;
  Map<String, Long> map;
  int mod = (int) (1e9 + 7);

  public int sumOfPowers(int[] nums, int k) {
    Arrays.sort(nums);
    this.nums = nums;
    map = new HashMap<>();
    return (int)dfs(nums.length-1,k,Integer.MAX_VALUE/2,Integer.MAX_VALUE/2);
  }

  public long dfs(int i, int rest, int pre, int min) {
    if (i + 1 < rest) {
      return 0;
    }
    if (rest == 0) {
      return min;
    }
    String key = i + "#" + rest + "#" + pre + "#" + min;
    if (map.containsKey(key)) {
      return map.get(key);
    }
    long res = 0L;
    res = (res + dfs(i - 1, rest, pre, min)) % mod;
    res = (res + dfs(i - 1, rest - 1, nums[i], Math.min(min, pre - nums[i]))) % mod;
    map.put(key, res);
    return res;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>重新放置石块

> <p>给你一个下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>nums</code>&nbsp;，表示一些石块的初始位置。再给你两个长度<strong>&nbsp;相等</strong>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>moveFrom</code> 和&nbsp;<code>moveTo</code>&nbsp;。</p>
> 
> <p>在&nbsp;<code>moveFrom.length</code>&nbsp;次操作内，你可以改变石块的位置。在第&nbsp;<code>i</code>&nbsp;次操作中，你将位置在&nbsp;<code>moveFrom[i]</code>&nbsp;的所有石块移到位置&nbsp;<code>moveTo[i]</code>&nbsp;。</p>
> 
> <p>完成这些操作后，请你按升序返回所有 <strong>有</strong>&nbsp;石块的位置。</p>
> 
> <p><strong>注意：</strong></p>
> 
> <ul>
> 	<li>如果一个位置至少有一个石块，我们称这个位置 <strong>有</strong>&nbsp;石块。</li>
> 	<li>一个位置可能会有多个石块。</li>
> </ul>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <b>输入：</b>nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]
> <b>输出：</b>[5,6,8,9]
> <b>解释：</b>一开始，石块在位置 1,6,7,8 。
> 第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，位置 2,6,7,8 有石块。
> 第 i = 1 步操作中，我们将位置 7 处的石块移到位置 9 处，位置 2,6,8,9 有石块。
> 第 i = 2 步操作中，我们将位置 2 处的石块移到位置 5 处，位置 5,6,8,9 有石块。
> 最后，至少有一个石块的位置为 [5,6,8,9] 。</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]
> <b>输出：</b>[2]
> <b>解释：</b>一开始，石块在位置 [1,1,3,3] 。
> 第 i = 0 步操作中，我们将位置 1 处的石块移到位置 2 处，有石块的位置为 [2,2,3,3] 。
> 第 i = 1 步操作中，我们将位置 3 处的石块移到位置 2 处，有石块的位置为 [2,2,2,2] 。
> 由于 2 是唯一有石块的位置，我们返回 [2] 。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= moveFrom.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>moveFrom.length == moveTo.length</code></li>
> 	<li><code>1 &lt;= nums[i], moveFrom[i], moveTo[i] &lt;= 10<sup>9</sup></code></li>
> 	<li>测试数据保证在进行第&nbsp;<code>i</code>&nbsp;步操作时，<code>moveFrom[i]</code>&nbsp;处至少有一个石块。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d24;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/*
 * https://leetcode.cn/problems/relocate-marbles/description/
 * */
class LC2766 {

  public List<Integer> relocateMarbles(int[] nums, int[] moveFrom, int[] moveTo) {
    return hashset(nums, moveFrom, moveTo);
  }

  /*
   * 第一种hashmap存储，移动时删除即可，第一时间没读对题，跟数量没关系，用set更好
   *
   * */
  public List<Integer> hashmap(int[] nums, int[] moveFrom, int[] moveTo) {
    Map<Integer, Integer> index2count = new HashMap<>();
    for (int num : nums) {
      index2count.put(num, index2count.getOrDefault(num, 0) + 1);
    }
    int n = moveFrom.length;
    for (int i = 0; i < n; i++) {
      int newFrom = index2count.get(moveFrom[i]);
      index2count.remove(moveFrom[i]);
      index2count.put(moveTo[i], index2count.getOrDefault(moveTo[i], 0) + newFrom);
    }
    return index2count.keySet().stream().sorted().collect(Collectors.toList());
  }

  /*
   * 第二种方法
   *  hashset 去重
   * */
  public List<Integer> hashset(int[] nums, int[] moveFrom, int[] moveTo) {
    Set<Integer> index = new HashSet<>();
    for (int num : nums) {
      index.add(num);
    }
    int n = moveFrom.length;
    for (int i = 0; i < n; i++) {
      index.remove(moveFrom[i]);
      index.add(moveTo[i]);
    }
    return index.stream().sorted().collect(Collectors.toList());
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>生成特殊数字的最少操作

> <p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>num</code> ，表示一个非负整数。</p>
> 
> <p>在一次操作中，您可以选择 <code>num</code> 的任意一位数字并将其删除。请注意，如果你删除 <code>num</code> 中的所有数字，则 <code>num</code> 变为 <code>0</code>。</p>
> 
> <p>返回最少需要多少次操作可以使 <code>num</code> 变成特殊数字。</p>
> 
> <p>如果整数 <code>x</code> 能被 <code>25</code> 整除，则该整数 <code>x</code> 被认为是特殊数字。</p>
> 
> <p>&nbsp;</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>num = "2245047"
> <strong>输出：</strong>2
> <strong>解释：</strong>删除数字 num[5] 和 num[6] ，得到数字 "22450" ，可以被 25 整除。
> 可以证明要使数字变成特殊数字，最少需要删除 2 位数字。</pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>num = "2908305"
> <strong>输出：</strong>3
> <strong>解释：</strong>删除 num[3]、num[4] 和 num[6] ，得到数字 "2900" ，可以被 25 整除。
> 可以证明要使数字变成特殊数字，最少需要删除 3 位数字。</pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>num = "10"
> <strong>输出：</strong>1
> <strong>解释：</strong>删除 num[0] ，得到数字 "0" ，可以被 25 整除。
> 可以证明要使数字变成特殊数字，最少需要删除 1 位数字。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= num.length &lt;= 100</code></li>
> 	<li><code>num</code> 仅由数字 <code>'0'</code> 到 <code>'9'</code> 组成</li>
> 	<li><code>num</code> 不含任何前导零</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d25;

/*
 * https://leetcode.cn/problems/minimum-operations-to-make-a-special-number/description/?envType=daily-question&envId=2024-07-25
 * */
class LC2844 {

  public int minimumOperations(String num) {
    int n = num.length();
    boolean found0 = false;
    boolean found5 = false;
    for (int i = n - 1; i >= 0; i--) {
      char c = num.charAt(i);
      if (found0 && (c == '0' || c == '5')
          || found5 && (c == '7' || c == '2')) {
        return n - i - 2;
      }
      if (c == '0') {
        found0 = true;
      } else if (c == '5') {
        found5 = true;
      }
    }
    return found0 ? n - 1 : n;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>找出分区值

> <p>给你一个 <strong>正</strong> 整数数组 <code>nums</code> 。</p>
> 
> <p>将 <code>nums</code> 分成两个数组：<code>nums1</code> 和 <code>nums2</code> ，并满足下述条件：</p>
> 
> <ul>
> 	<li>数组 <code>nums</code> 中的每个元素都属于数组 <code>nums1</code> 或数组 <code>nums2</code> 。</li>
> 	<li>两个数组都 <strong>非空</strong> 。</li>
> 	<li>分区值 <strong>最小</strong> 。</li>
> </ul>
> 
> <p>分区值的计算方法是 <code>|max(nums1) - min(nums2)|</code> 。</p>
> 
> <p>其中，<code>max(nums1)</code> 表示数组 <code>nums1</code> 中的最大元素，<code>min(nums2)</code> 表示数组 <code>nums2</code> 中的最小元素。</p>
> 
> <p>返回表示分区值的整数。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre><strong>输入：</strong>nums = [1,3,2,4]
> <strong>输出：</strong>1
> <strong>解释：</strong>可以将数组 nums 分成 nums1 = [1,2] 和 nums2 = [3,4] 。
> - 数组 nums1 的最大值等于 2 。
> - 数组 nums2 的最小值等于 3 。
> 分区值等于 |2 - 3| = 1 。
> 可以证明 1 是所有分区方案的最小值。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre><strong>输入：</strong>nums = [100,1,10]
> <strong>输出：</strong>9
> <strong>解释：</strong>可以将数组 nums 分成 nums1 = [10] 和 nums2 = [100,1] 。 
> - 数组 nums1 的最大值等于 10 。 
> - 数组 nums2 的最小值等于 1 。 
> 分区值等于 |10 - 1| = 9 。 
> 可以证明 9 是所有分区方案的最小值。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d26;

import java.util.Arrays;

/*
 * https://leetcode.cn/problems/find-the-value-of-the-partition/?envType=daily-question&envId=2024-07-26
 * */
class LC2740 {

  //贪心 找出两个数的最小差(绝对值)
  public int findValueOfPartition(int[] nums) {
    Arrays.sort(nums);
    int res = Integer.MAX_VALUE;
    for (int i = 1; i < nums.length; i++) {
      res = Math.min(res, nums[i] - nums[i - 1]);
    }
    return res;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>满足距离约束且字典序最小的字符串

> <p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。</p>
> 
> <p>定义函数 <code>distance(s<sub>1</sub>, s<sub>2</sub>)</code> ，用于衡量两个长度为 <code>n</code> 的字符串 <code>s<sub>1</sub></code> 和 <code>s<sub>2</sub></code> 之间的距离，即：</p>
> 
> <ul>
> 	<li>字符 <code>'a'</code> 到 <code>'z'</code> 按 <strong>循环 </strong>顺序排列，对于区间 <code>[0, n - 1]</code> 中的 <code>i</code> ，计算所有「 <code>s<sub>1</sub>[i]</code> 和 <code>s<sub>2</sub>[i]</code> 之间<strong> 最小距离</strong>」的 <strong>和 </strong>。</li>
> </ul>
> 
> <p>例如，<code>distance("ab", "cd") == 4</code> ，且 <code>distance("a", "z") == 1</code> 。</p>
> 
> <p>你可以对字符串 <code>s</code> 执行<strong> 任意次 </strong>操作。在每次操作中，可以将 <code>s</code> 中的一个字母 <strong>改变 </strong>为<strong> 任意 </strong>其他小写英文字母。</p>
> 
> <p>返回一个字符串，表示在执行一些操作后你可以得到的 <strong>字典序最小</strong> 的字符串 <code>t</code> ，且满足 <code>distance(s, t) &lt;= k</code> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "zbbz", k = 3
> <strong>输出：</strong>"aaaz"
> <strong>解释：</strong>在这个例子中，可以执行以下操作：
> 将 s[0] 改为 'a' ，s 变为 "abbz" 。
> 将 s[1] 改为 'a' ，s 变为 "aabz" 。
> 将 s[2] 改为 'a' ，s 变为 "aaaz" 。
> "zbbz" 和 "aaaz" 之间的距离等于 k = 3 。
> 可以证明 "aaaz" 是在任意次操作后能够得到的字典序最小的字符串。
> 因此，答案是 "aaaz" 。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "xaxcd", k = 4
> <strong>输出：</strong>"aawcd"
> <strong>解释：</strong>在这个例子中，可以执行以下操作：
> 将 s[0] 改为 'a' ，s 变为 "aaxcd" 。
> 将 s[2] 改为 'w' ，s 变为 "aawcd" 。
> "xaxcd" 和 "aawcd" 之间的距离等于 k = 4 。
> 可以证明 "aawcd" 是在任意次操作后能够得到的字典序最小的字符串。
> 因此，答案是 "aawcd" 。
> </pre>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>s = "lol", k = 0
> <strong>输出：</strong>"lol"
> <strong>解释：</strong>在这个例子中，k = 0，更改任何字符都会使得距离大于 0 。
> 因此，答案是 "lol" 。</pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= s.length &lt;= 100</code></li>
> 	<li><code>0 &lt;= k &lt;= 2000</code></li>
> 	<li><code>s</code> 只包含小写英文字母。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d27;

/*
 * https://leetcode.cn/problems/lexicographically-smallest-string-after-operations-with-constraint/
 * */
class LC3106 {

  StringBuffer res;

  public String getSmallestString(String s, int k) {
//    res = new StringBuffer();
//    dfs(k, s);
//    return res.toString();

    char[] chars = s.toCharArray();
    for (int i = 0; i < chars.length; i++) {
      int dis = Math.min(chars[i] - 'a', 'z' - chars[i] + 1);
      if (dis > k) {
        chars[i] -= k;
        break;
      } else {
        chars[i] = 'a';
        k -= dis;
      }
    }
    return new String(chars);
  }

  //  方法2 递归
  public void dfs(int k, String s) {
    if (k == 0 || s.equals("")) {
      res.append(s);
      return;
    }
    char first = s.charAt(0);
    int actualDis = first - 'a';
    int distance = Math.min('a' - first + 26, first - 'a');
    if (distance <= k) {
      res.append('a');
      dfs(k - distance, s.substring(1));
    } else {
      res.append((char) (first - k)).append(s.substring(1));
    }
  }

}
```
</li>
</ul>
</li>
<li>
<ul>
<li>掉落的方块

> <p>在二维平面上的 x 轴上，放置着一些方块。</p>
> 
> <p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLength<sub>i</sub></code> ，其左侧边与 x 轴上坐标点&nbsp;<code>left<sub>i</sub></code> 对齐。</p>
> 
> <p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>
> 
> <p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>
> 
> <p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong>示例 1：</strong></p>
> <img alt="" src="https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg" style="width: 500px; height: 505px;" />
> <pre>
> <strong>输入：</strong>positions = [[1,2],[2,3],[6,1]]
> <strong>输出：</strong>[2,5,5]
> <strong>解释：</strong>
> 第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。
> 第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。
> 第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。
> 因此，返回 [2, 5, 5] 作为答案。
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>positions = [[100,100],[200,100]]
> <strong>输出：</strong>[100,100]
> <strong>解释：</strong>
> 第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。
> 第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。
> 因此，返回 [100, 100] 作为答案。
> 注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= positions.length &lt;= 1000</code></li>
> 	<li><code>1 &lt;= left<sub>i</sub> &lt;= 10<sup>8</sup></code></li>
> 	<li><code>1 &lt;= sideLength<sub>i</sub> &lt;= 10<sup>6</sup></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d28;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/*
 * https://leetcode.cn/problems/falling-squares/
 * */
class LC699 {

  public List<Integer> fallingSquares(int[][] positions) {
    return normal(positions);
  }

  //  暴力枚举, 将先前的每个方块的高度有序存起来, 从大到小确认是否与当前方块重合, 更新高度
  public List<Integer> normal(int[][] positions) {
    int n = positions.length;
    List<Integer> ans = new ArrayList<>();
    ans.add(positions[0][1]);
    LinkedList<int[]> pres = new LinkedList<>();
    pres.add(new int[]{0, positions[0][1]});
    for (int i = 1; i < n; i++) {
      // 当前方块
      int[] curr = positions[i];
      int toEndHigh = curr[1];
      // 上一次最高高度
      int lastHighest = ans.get(i - 1);
      boolean toEnd = true;
      int size = pres.size();
      // 向前艺高度顺序从大到小比对是否落在了方块上
      for (int j = size - 1; j >= 0; j--) {
        //待对比方块的下标
        int highestIndex = pres.get(j)[0];
        // 待对比方块所处高度
        int high = pres.get(j)[1];
        // 待对比方块
        int[] position = positions[highestIndex];
        // 如果两个方块区间重合，说明落在该方块上了，则更新高度和dp
        if (!(curr[0] >= position[0] + position[1]
            || curr[0] + curr[1] <= position[0])) {

          int currHigh = high + curr[1];
          ans.add(i, Math.max(currHigh, lastHighest));
          addToList(i, currHigh, pres);
          toEnd = false;
          break;
        }
      }
      if (toEnd) {
        ans.add(i, Math.max(toEndHigh, lastHighest));
        addToList(i, toEndHigh, pres);
      }
    }
    return ans;

  }

  public void addToList(int i, int currHigh, List<int[]> pres) {
    int size = pres.size();
    boolean isLast = true;
    for (int k = size - 1; k >= 0; k--) {
      if (currHigh > pres.get(k)[1]) {
        pres.add(k + 1, new int[]{i, currHigh});
        isLast = false;
        break;
      }
    }
    if (isLast) {
      pres.add(0, new int[]{i, currHigh});
    }
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>棒球比赛

> <p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
> 
> <p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>
> 
> <ol>
> 	<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>
> 	<li><code>"+"</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>
> 	<li><code>"D"</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
> 	<li><code>"C"</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
> </ol>
> 
> <p>请你返回记录中所有得分的总和。</p>
> 
> <p> </p>
> 
> <p><strong>示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>ops = ["5","2","C","D","+"]
> <strong>输出：</strong>30
> <strong>解释：</strong>
> "5" - 记录加 5 ，记录现在是 [5]
> "2" - 记录加 2 ，记录现在是 [5, 2]
> "C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].
> "D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].
> "+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].
> 所有得分的总和 5 + 10 + 15 = 30
> </pre>
> 
> <p><strong>示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>ops = ["5","-2","4","C","D","9","+","+"]
> <strong>输出：</strong>27
> <strong>解释：</strong>
> "5" - 记录加 5 ，记录现在是 [5]
> "-2" - 记录加 -2 ，记录现在是 [5, -2]
> "4" - 记录加 4 ，记录现在是 [5, -2, 4]
> "C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]
> "D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]
> "9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]
> "+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]
> "+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]
> 所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27
> </pre>
> 
> <p><strong>示例 3：</strong></p>
> 
> <pre>
> <strong>输入：</strong>ops = ["1"]
> <strong>输出：</strong>1
> </pre>
> 
> <p> </p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 <= ops.length <= 1000</code></li>
> 	<li><code>ops[i]</code> 为 <code>"C"</code>、<code>"D"</code>、<code>"+"</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code></li>
> 	<li>对于 <code>"+"</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li>
> 	<li>对于 <code>"C"</code> 和 <code>"D"</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d29;

import java.util.ArrayList;
import java.util.List;

class LC682 {

  public int calPoints(String[] operations) {
    List<Integer> scores = new ArrayList<>();
    int res = 0;
    for (String operation : operations) {
      int size = scores.size();
      int newScore;
      switch (operation) {
        case "+":
          newScore = scores.get(size - 1) + scores.get(size - 2);
          scores.add(newScore);
          break;
        case "D":
          newScore = scores.get(size - 1) * 2;
          scores.add(newScore);
          break;
        case "C":
          newScore = -scores.remove(size - 1);
          break;
        default:
          newScore = Integer.parseInt(operation);
          scores.add(newScore);
      }
      res += newScore;
    }
    return res;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>双模幂运算

> <p>给你一个下标从 <strong>0 </strong>开始的二维数组 <code>variables</code> ，其中 <code>variables[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i,</sub> m<sub>i</sub>]</code>，以及一个整数 <code>target</code> 。</p>
> 
> <p>如果满足以下公式，则下标 <code>i</code> 是 <strong>好下标</strong>：</p>
> 
> <ul>
> 	<li><code>0 &lt;= i &lt; variables.length</code></li>
> 	<li><code>((a<sub>i</sub><sup>b<sub>i</sub></sup> % 10)<sup>c<sub>i</sub></sup>) % m<sub>i</sub> == target</code></li>
> </ul>
> 
> <p>返回一个由<strong> 好下标 </strong>组成的数组，<strong>顺序不限</strong> 。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <pre>
> <strong>输入：</strong>variables = [[2,3,3,10],[3,3,3,1],[6,1,1,4]], target = 2
> <strong>输出：</strong>[0,2]
> <strong>解释：</strong>对于 variables 数组中的每个下标 i ：
> 1) 对于下标 0 ，variables[0] = [2,3,3,10] ，(2<sup>3</sup> % 10)<sup>3</sup> % 10 = 2 。
> 2) 对于下标 1 ，variables[1] = [3,3,3,1] ，(3<sup>3</sup> % 10)<sup>3</sup> % 1 = 0 。
> 3) 对于下标 2 ，variables[2] = [6,1,1,4] ，(6<sup>1</sup> % 10)<sup>1</sup> % 4 = 2 。
> 因此，返回 [0,2] 作为答案。
> </pre>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <pre>
> <strong>输入：</strong>variables = [[39,3,1000,1000]], target = 17
> <strong>输出：</strong>[]
> <strong>解释：</strong>对于 variables 数组中的每个下标 i ：
> 1) 对于下标 0 ，variables[0] = [39,3,1000,1000] ，(39<sup>3</sup> % 10)<sup>1000</sup> % 1000 = 1 。
> 因此，返回 [] 作为答案。
> </pre>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= variables.length &lt;= 100</code></li>
> 	<li><code>variables[i] == [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, m<sub>i</sub>]</code></li>
> 	<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, m<sub>i</sub> &lt;= 10<sup>3</sup></code></li>
> 	<li><code><font face="monospace">0 &lt;= target &lt;= 10<sup>3</sup></font></code></li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d30;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class LC2961 {

  public List<Integer> getGoodIndices(int[][] variables, int target) {
    Set<Integer> ans = new HashSet<>();
    for (int i = 0; i < variables.length; i++) {
      int a = variables[i][0];
      int b = variables[i][1];
      int c = variables[i][2];
      int m = variables[i][3];
      int val = pow(pow(a, b, 10), c, m);
      if (val == target) {
        ans.add(i);
      }
    }
    return new ArrayList<>(ans);
  }

  public int pow(int a, int n, int mod) {
    int ans = 1;
    while (n > 0) {
      if ((n & 1) == 1) {
        ans = ans * a % mod;
      }
      a = a * a % mod;
      n = n >> 1;
    }
    return ans;
  }
}
```
</li>
</ul>
</li>
<li>
<ul>
<li>3111

> <p>给你一个二维整数数组&nbsp;<code>point</code>&nbsp;，其中&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;表示二维平面内的一个点。同时给你一个整数&nbsp;<code>w</code>&nbsp;。你需要用矩形&nbsp;<strong>覆盖所有</strong>&nbsp;点。</p>
> 
> <p>每个矩形的左下角在某个点&nbsp;<code>(x<sub>1</sub>, 0)</code>&nbsp;处，且右上角在某个点&nbsp;<code>(x<sub>2</sub>, y<sub>2</sub>)</code>&nbsp;处，其中&nbsp;<code>x<sub>1</sub> &lt;= x<sub>2</sub></code>&nbsp;且&nbsp;<code>y<sub>2</sub> &gt;= 0</code>&nbsp;，同时对于每个矩形都&nbsp;<strong>必须</strong>&nbsp;满足&nbsp;<code>x<sub>2</sub> - x<sub>1</sub> &lt;= w</code>&nbsp;。</p>
> 
> <p>如果一个点在矩形内或者在边上，我们说这个点被矩形覆盖了。</p>
> 
> <p>请你在确保每个点都 <strong>至少</strong>&nbsp;被一个矩形覆盖的前提下，<strong>最少</strong>&nbsp;需要多少个矩形。</p>
> 
> <p><strong>注意：</strong>一个点可以被多个矩形覆盖。</p>
> 
> <p>&nbsp;</p>
> 
> <p><strong class="example">示例 1：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-20-33-05.png" style="width: 205px; height: 300px;" /></p>
> 
> <div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
> <p style=""><span class="example-io" style="font-size: 8.75px;"><b>输入：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1</span></p>
> 
> <p style=""><span class="example-io" style="font-size: 8.75px;"><b>输出：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">2</span></p>
> 
> <p style="font-size: 0.875rem;"><strong>解释：</strong></p>
> 
> <p style="font-size: 0.875rem;">上图展示了一种可行的矩形放置方案：</p>
> 
> <ul style="font-size: 0.875rem;">
> 	<li>一个矩形的左下角在&nbsp;<code>(1, 0)</code>&nbsp;，右上角在&nbsp;<code>(2, 8)</code>&nbsp;。</li>
> 	<li>一个矩形的左下角在&nbsp;<code>(3, 0)</code>&nbsp;，右上角在&nbsp;<code>(4, 8)</code>&nbsp;。</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 2：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-18-59-12.png" style="width: 260px; height: 250px;" /></p>
> 
> <div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
> <p style=""><span class="example-io" style="font-size: 8.75px;"><b>输入：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2</span></p>
> 
> <p style=""><span class="example-io" style="font-size: 8.75px;"><b>输出：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">3</span></p>
> 
> <p style="font-size: 0.875rem;"><b>解释：</b></p>
> 
> <p style="font-size: 0.875rem;">上图展示了一种可行的矩形放置方案：</p>
> 
> <ul style="font-size: 0.875rem;">
> 	<li>一个矩形的左下角在&nbsp;<code>(0, 0)</code>&nbsp;，右上角在&nbsp;<code>(2, 2)</code>&nbsp;。</li>
> 	<li>一个矩形的左下角在&nbsp;<code>(3, 0)</code>&nbsp;，右上角在&nbsp;<code>(5, 5)</code>&nbsp;。</li>
> 	<li>一个矩形的左下角在&nbsp;<code>(6, 0)</code>&nbsp;，右上角在&nbsp;<code>(6, 6)</code>&nbsp;。</li>
> </ul>
> </div>
> 
> <p><strong class="example">示例 3：</strong></p>
> 
> <p><img alt="" src="https://assets.leetcode.com/uploads/2024/03/04/screenshot-from-2024-03-04-20-24-03.png" style="height: 150px; width: 127px;" /></p>
> 
> <div class="example-block" style="border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;">
> <p style=""><span class="example-io" style="font-size: 8.75px;"><b>输入：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">points = [[2,3],[1,2]], w = 0</span></p>
> 
> <p style=""><span class="example-io" style="font-size: 8.75px;"><b>输出：</b></span><span class="example-io" style="font-size: 0.85rem; font-family: Menlo, sans-serif;">2</span></p>
> 
> <p style="font-size: 0.875rem;"><strong>解释：</strong></p>
> 
> <p style="font-size: 0.875rem;">上图展示了一种可行的矩形放置方案：</p>
> 
> <ul style="font-size: 0.875rem;">
> 	<li>一个矩形的左下角在&nbsp;<code>(1, 0)</code>&nbsp;，右上角在&nbsp;<code>(1, 2)</code>&nbsp;。</li>
> 	<li>一个矩形的左下角在&nbsp;<code>(2, 0)</code>&nbsp;，右上角在&nbsp;<code>(2, 3)</code>&nbsp;。</li>
> </ul>
> </div>
> 
> <p>&nbsp;</p>
> 
> <p><strong>提示：</strong></p>
> 
> <ul>
> 	<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>
> 	<li><code>points[i].length == 2</code></li>
> 	<li><code>0 &lt;= x<sub>i</sub> == points[i][0] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= y<sub>i</sub> == points[i][1] &lt;= 10<sup>9</sup></code></li>
> 	<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>
> 	<li>所有点坐标&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;互不相同。</li>
> </ul>

</li>
<li>java solution

```java
package com.hyperboat.daily.y2024.m07.d31;

import java.util.Arrays;
import java.util.Comparator;

/*
 * https://leetcode.cn/problems/minimum-rectangles-to-cover-points/description/
 * */
class LC3111 {

  // 简简单单一个贪心
  public int minRectanglesToCoverPoints(int[][] points, int w) {
    int n = points.length;
    Arrays.sort(points, Comparator.comparingInt(o -> o[0]));
    int rangeR = -1;
    int ans = 0;
    for (int i = 0; i < n; i++) {
      int[] point = points[i];
      if (point[0] > rangeR) {
        ans++;
        rangeR = point[0] + w;
      }
    }
    return ans;
  }

}
```
</li>
</ul>
</li>
</ol>
